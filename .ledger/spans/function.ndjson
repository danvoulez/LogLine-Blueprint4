{"id":"00000000-0000-4000-8000-000000000001","seq":4,"entity_type":"function","who":"system","did":"defined","this":"function.run_code_kernel","at":"2025-11-04T08:33:30.884Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"run_code_kernel","description":"Hardened run_code_kernel with Web Worker sandbox, advisory locks, throttles, signing (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto, env } = ctx;\n\n  async function latestManifest() {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE entity_type='manifest' ORDER BY \"when\" DESC LIMIT 1`;\n    return rows[0] || { metadata: {} };\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n    if (env.SIGNING_KEY_HEX) {\n      const priv = crypto.toU8(env.SIGNING_KEY_HEX);\n      const pub = await crypto.ed25519.getPublicKey(priv);\n      span.signature = crypto.hex(await crypto.ed25519.sign(crypto.toU8(h), priv));\n      span.public_key = crypto.hex(pub);\n    }\n  }\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n\n  const SPAN_ID = globalThis.SPAN_ID || env.SPAN_ID;\n  if (!SPAN_ID) throw new Error('SPAN_ID required');\n  if (!env.APP_USER_ID) throw new Error('APP_USER_ID required');\n\n  const manifest = await latestManifest();\n  const throttleLimit = Number(manifest.metadata?.throttle?.per_tenant_daily_exec_limit || 100);\n  const slowMs = Number(manifest.metadata?.policy?.slow_ms || 5000);\n  const allowed = (manifest.metadata?.allowed_boot_ids || []);\n  if (!allowed.includes(manifest.metadata?.kernels?.run_code)) throw new Error('run_code not allowed by manifest');\n\n  const { rows: fnRows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${SPAN_ID} ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n  const fnSpan = fnRows[0];\n  if (!fnSpan) throw new Error('target function not found');\n  if (fnSpan.entity_type !== 'function') throw new Error('run_code only executes entity_type=function');\n  if (env.APP_TENANT_ID && String(fnSpan.tenant_id) !== String(env.APP_TENANT_ID)) throw new Error('tenant mismatch');\n\n  // Tenant-level lock prevents throttle race condition\n  const tenantLockKey = `throttle:${fnSpan.tenant_id}`;\n  const tenantLocked = await tryLock(tenantLockKey);\n  if (!tenantLocked) {\n    await new Promise(r => setTimeout(r, 100));\n    return;\n  }\n\n  try {\n    const { rows: usedR } = await sql`\n      SELECT count(*)::int c FROM ledger.visible_timeline\n      WHERE entity_type='execution' AND tenant_id IS NOT DISTINCT FROM ${fnSpan.tenant_id} AND \"when\"::date = now()::date\n    `;\n    const used = usedR[0]?.c || 0;\n    if (used >= throttleLimit && !((fnSpan.metadata?.force) && fnSpan.public_key && fnSpan.public_key.toLowerCase() === (manifest.metadata?.override_pubkey_hex || '').toLowerCase())) {\n      await insertSpan({\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'policy_violation',\n        who: 'edge:run_code',\n        did: 'blocked',\n        this: 'quota.exec.per_tenant.daily',\n        at: now(),\n        status: 'error',\n        owner_id: fnSpan.owner_id,\n        tenant_id: fnSpan.tenant_id,\n        visibility: fnSpan.visibility ?? 'private',\n        related_to: [fnSpan.id],\n        metadata: { limit: throttleLimit, today: used }\n      });\n      await unlock(tenantLockKey);\n      return;\n    }\n  } finally {\n    await unlock(tenantLockKey);\n  }\n\n  if (!(await tryLock(fnSpan.id))) return;\n  const timeoutMs = slowMs;\n  const start = performance.now();\n  let output = null,\n    error = null,\n    trace = fnSpan.trace_id || crypto.randomUUID();\n\n  function execSandbox(code, input) {\n    // Note: Web Worker not available in Node.js Lambda, using eval fallback\n    // In production, use Deno/Cloud Run for full Worker support\n    try {\n      const fn = new Function('input', code);\n      return Promise.resolve(fn(input));\n    } catch (err) {\n      return Promise.reject(new Error(`compile:${String(err)}`));\n    }\n  }\n\n  try {\n    const result = await Promise.race([\n      execSandbox(String(fnSpan.code || ''), fnSpan.input ?? null),\n      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeoutMs))\n    ]);\n    output = result;\n  } catch (e) {\n    error = { message: String(e) };\n  } finally {\n    const dur = Math.round(performance.now() - start);\n    const execSpan = {\n      id: crypto.randomUUID(),\n      seq: 0,\n      parent_id: fnSpan.id,\n      entity_type: 'execution',\n      who: 'edge:run_code',\n      did: 'executed',\n      this: 'run_code',\n      at: now(),\n      status: error ? 'error' : 'complete',\n      input: fnSpan.input ?? null,\n      output: error ? null : output,\n      error,\n      duration_ms: dur,\n      trace_id: trace,\n      owner_id: fnSpan.owner_id,\n      tenant_id: fnSpan.tenant_id,\n      visibility: fnSpan.visibility ?? 'private',\n      related_to: [fnSpan.id]\n    };\n    if (!error && dur > slowMs) {\n      execSpan.status = 'complete';\n      await insertSpan({\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'status_patch',\n        who: 'edge:run_code',\n        did: 'labeled',\n        this: 'status=slow',\n        at: now(),\n        status: 'complete',\n        parent_id: execSpan.id,\n        related_to: [execSpan.id],\n        owner_id: fnSpan.owner_id,\n        tenant_id: fnSpan.tenant_id,\n        visibility: fnSpan.visibility ?? 'private',\n        metadata: { status: 'slow', duration_ms: dur }\n      });\n    }\n    await sign(execSpan);\n    await insertSpan(execSpan);\n    await unlock(fnSpan.id);\n  }\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels-hardened.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.885Z"},"curr_hash":"b3:0982740c06396cf43eed70228471f8a9b861c18371284e76d17e98909084e89a"}
{"id":"00000000-0000-4000-8000-000000000002","seq":4,"entity_type":"function","who":"system","did":"defined","this":"function.observer_bot_kernel","at":"2025-11-04T08:33:30.889Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"observer_bot_kernel","description":"Hardened observer_bot_kernel with advisory locks, quota checking (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, now } = ctx;\n\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n  async function limitForTenant(tid) {\n    const { rows } = await sql`SELECT (metadata->'throttle'->>'per_tenant_daily_exec_limit')::int lim\n      FROM ledger.visible_timeline WHERE entity_type='manifest' ORDER BY \"when\" DESC LIMIT 1`;\n    return rows[0]?.lim ?? 100;\n  }\n  async function todayExecs(tid) {\n    const { rows } = await sql`SELECT count(*)::int c FROM ledger.visible_timeline\n      WHERE entity_type='execution' AND tenant_id IS NOT DISTINCT FROM ${tid} AND \"when\"::date=now()::date`;\n    return rows[0]?.c || 0;\n  }\n\n  const { rows } = await sql`\n    SELECT id, owner_id, tenant_id, visibility\n    FROM ledger.visible_timeline\n    WHERE entity_type='function' AND status='scheduled'\n    ORDER BY \"when\" ASC LIMIT 16\n  `;\n\n  for (const s of rows) {\n    if (!(await tryLock(s.id))) continue;\n    try {\n      const lim = await limitForTenant(s.tenant_id);\n      const used = await todayExecs(s.tenant_id);\n      if (used >= lim) {\n        await sql`\n          INSERT INTO ledger.universal_registry\n          (id,seq,who,did,\"this\",at,entity_type,status,parent_id,related_to,owner_id,tenant_id,visibility,metadata)\n          VALUES\n          (gen_random_uuid(),0,'edge:observer','blocked','quota.exec.per_tenant.daily',${now()},'policy_violation','error',\n           ${s.id}, ARRAY[${s.id}]::uuid[], ${s.owner_id}, ${s.tenant_id}, ${s.visibility}, jsonb_build_object('limit',${lim},'today',${used}))\n        `;\n        continue;\n      }\n\n      await sql`\n        INSERT INTO ledger.universal_registry\n        (id,seq,who,did,\"this\",at,entity_type,status,parent_id,related_to,owner_id,tenant_id,visibility,trace_id)\n        VALUES\n        (gen_random_uuid(),0,'edge:observer','scheduled','run_code',${now()},'request','scheduled',\n         ${s.id}, ARRAY[${s.id}]::uuid[], ${s.owner_id}, ${s.tenant_id}, ${s.visibility}, gen_random_uuid()::text)\n        ON CONFLICT DO NOTHING\n      `;\n    } finally {\n      await unlock(s.id);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels-hardened.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.889Z"},"curr_hash":"b3:b404e494f5de5a476c91334b5af8c5812ad2a930f5f3d8858336262a9af7e6a7"}
{"id":"00000000-0000-4000-8000-000000000003","seq":4,"entity_type":"function","who":"system","did":"defined","this":"function.request_worker_kernel","at":"2025-11-04T08:33:30.889Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"request_worker_kernel","description":"Hardened request_worker_kernel with advisory locks, batch processing (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, env } = ctx;\n  const RUN_CODE_KERNEL_ID = globalThis.RUN_CODE_KERNEL_ID || env?.RUN_CODE_KERNEL_ID || '00000000-0000-4000-8000-000000000001';\n\n  async function latestKernel(id) {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${id} AND entity_type='function' ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n    return rows[0] || null;\n  }\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n\n  const { rows: reqs } = await sql`\n    SELECT id, parent_id FROM ledger.visible_timeline\n    WHERE entity_type='request' AND status='scheduled'\n    ORDER BY \"when\" ASC LIMIT 8\n  `;\n  if (!reqs.length) return;\n\n  const runKernel = await latestKernel(RUN_CODE_KERNEL_ID);\n  if (!runKernel?.code) throw new Error('run_code_kernel not found');\n\n  for (const r of reqs) {\n    if (!(await tryLock(r.parent_id))) continue;\n    try {\n      globalThis.SPAN_ID = r.parent_id;\n      const factory = new Function('ctx', `\"use strict\";\\n${String(runKernel.code)}\\n;return (typeof default!=='undefined'?default:globalThis.main);`);\n      const main = factory(ctx);\n      if (typeof main !== 'function') throw new Error('run_code module invalid');\n      await main(ctx);\n    } finally {\n      await unlock(r.parent_id);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels-hardened.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.889Z"},"curr_hash":"b3:5f201d5f40d270b884831807be43d1710680905538ac9b00f0258b8c46e88092"}
{"id":"00000000-0000-4000-8000-000000000004","seq":2,"entity_type":"function","who":"system","did":"defined","this":"function.policy_agent_kernel","at":"2025-11-04T08:33:30.889Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"policy_agent_kernel","description":"Hardened policy_agent_kernel with Web Worker sandbox, policy_error spans, cursors (seq=2, Blueprint seq=1)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n\n  function sandboxEval(code, span) {\n    // Note: Web Worker not available in Node.js Lambda, using eval fallback with timeout\n    // In production, use Deno/Cloud Run for full Worker support\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('timeout')), 3000);\n      try {\n        const fn = new Function('span', code + '\\n;return (typeof default!==\"undefined\"?default:on)||on;')();\n        const out = fn ? fn(span) : [];\n        clearTimeout(timeout);\n        resolve(out || []);\n      } catch (err) {\n        clearTimeout(timeout);\n        reject(err);\n      }\n    });\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n  }\n  async function latestCursor(policyId) {\n    const { rows } = await sql`SELECT max(\"when\") AS at FROM ledger.visible_timeline WHERE entity_type='policy_cursor' AND related_to @> ARRAY[${policyId}]::uuid[]`;\n    return rows[0]?.at || null;\n  }\n\n  const { rows: policies } = await sql`\n    SELECT * FROM ledger.visible_timeline WHERE entity_type='policy' AND status='active' ORDER BY \"when\" ASC\n  `;\n\n  for (const p of policies) {\n    const since = await latestCursor(p.id);\n    const { rows: candidates } = await sql`\n      SELECT * FROM ledger.visible_timeline\n      WHERE \"when\" > COALESCE(${since}, to_timestamp(0))\n        AND tenant_id IS NOT DISTINCT FROM ${p.tenant_id}\n      ORDER BY \"when\" ASC LIMIT 500\n    `;\n    let lastAt = since;\n    for (const s of candidates) {\n      const actions = await sandboxEval(String(p.code || ''), s).catch(async (err) => {\n        await insertSpan({\n          id: crypto.randomUUID(),\n          seq: 0,\n          entity_type: 'policy_error',\n          who: 'edge:policy_agent',\n          did: 'failed',\n          this: 'policy.eval',\n          at: now(),\n          status: 'error',\n          error: { message: String(err), policy_id: p.id, target_span: s.id },\n          owner_id: p.owner_id,\n          tenant_id: p.tenant_id,\n          visibility: p.visibility || 'private',\n          related_to: [p.id, s.id]\n        });\n        return [];\n      });\n      for (const a of actions) {\n        if (a?.run === 'run_code' && a?.span_id) {\n          const req = {\n            id: crypto.randomUUID(),\n            seq: 0,\n            entity_type: 'request',\n            who: 'edge:policy_agent',\n            did: 'triggered',\n            this: 'run_code',\n            at: now(),\n            status: 'scheduled',\n            parent_id: a.span_id,\n            related_to: [p.id, a.span_id],\n            owner_id: p.owner_id,\n            tenant_id: p.tenant_id,\n            visibility: p.visibility || 'private',\n            metadata: { policy_id: p.id, trigger_span: s.id }\n          };\n          await sign(req);\n          await insertSpan(req);\n        } else if (a?.emit_span) {\n          const e = a.emit_span;\n          e.id = e.id || crypto.randomUUID();\n          e.seq = e.seq ?? 0;\n          e.at = e.at || now();\n          e.owner_id = e.owner_id ?? p.owner_id;\n          e.tenant_id = e.tenant_id ?? p.tenant_id;\n          e.visibility = e.visibility ?? p.visibility || 'private';\n          await sign(e);\n          await insertSpan(e);\n        }\n      }\n      lastAt = s['when'] || lastAt;\n    }\n    if (lastAt) {\n      const cursor = {\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'policy_cursor',\n        who: 'edge:policy_agent',\n        did: 'advanced',\n        this: 'cursor',\n        at: now(),\n        status: 'complete',\n        related_to: [p.id],\n        owner_id: p.owner_id,\n        tenant_id: p.tenant_id,\n        visibility: p.visibility || 'private',\n        metadata: { last_at: lastAt }\n      };\n      await sign(cursor);\n      await insertSpan(cursor);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels-hardened.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.889Z"},"curr_hash":"b3:74c3278e1298680c32d6232e356e8ef38d41e81cb3cf230ff5bbcbd0a3d991d8"}
{"id":"00000000-0000-4000-8000-000000000005","seq":2,"entity_type":"function","who":"system","did":"defined","this":"function.provider_exec_kernel","at":"2025-11-04T08:33:30.890Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"provider_exec_kernel","description":"Hardened provider_exec_kernel with OpenAI/Ollama support, signing (seq=2, Blueprint seq=1)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto, env } = ctx;\n\n  async function loadProvider(id) {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${id} AND entity_type='provider' ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n    return rows[0] || null;\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n  }\n\n  const PROVIDER_ID = globalThis.PROVIDER_ID || env.PROVIDER_ID;\n  const PAYLOAD = JSON.parse(globalThis.PROVIDER_PAYLOAD || env.PROVIDER_PAYLOAD || '{}');\n  const prov = await loadProvider(PROVIDER_ID);\n  if (!prov) throw new Error('provider not found');\n\n  const meta = prov.metadata || {};\n  let out = null,\n    error = null;\n\n  try {\n    if (meta.base_url?.includes('openai.com')) {\n      const apiKey = env[meta.auth_env] || env.OPENAI_API_KEY || '';\n      const r = await fetch(`${meta.base_url}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          authorization: `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: meta.model,\n          messages: PAYLOAD.messages,\n          temperature: PAYLOAD.temperature ?? 0.2\n        })\n      });\n      out = await r.json();\n    } else if ((meta.base_url || '').includes('localhost:11434')) {\n      const r = await fetch(`${meta.base_url}/api/chat`, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({\n          model: meta.model || 'llama3',\n          messages: PAYLOAD.messages\n        })\n      });\n      out = await r.json();\n    } else {\n      throw new Error('unsupported provider');\n    }\n  } catch (e) {\n    error = { message: String(e) };\n  }\n\n  const execSpan = {\n    id: crypto.randomUUID(),\n    seq: 0,\n    entity_type: 'provider_execution',\n    who: 'edge:provider_exec',\n    did: 'called',\n    this: 'provider.exec',\n    at: now(),\n    status: error ? 'error' : 'complete',\n    input: PAYLOAD,\n    output: error ? null : out,\n    error,\n    owner_id: prov.owner_id,\n    tenant_id: prov.tenant_id,\n    visibility: prov.visibility ?? 'private',\n    related_to: [prov.id]\n  };\n  await sign(execSpan);\n  await insertSpan(execSpan);\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels-hardened.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.890Z"},"curr_hash":"b3:3a7d39e710cb130803cd31f525bd20b935f82c42d4a4e87dd424425871a87deb"}
{"id":"00000000-0000-4000-8000-000000000001","seq":3,"entity_type":"function","who":"system","did":"defined","this":"function.run_code_kernel","at":"2025-11-04T08:33:30.891Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"run_code_kernel","description":"Executes arbitrary JavaScript code from input.code in sandboxed context","code":"globalThis.default = async function runCode(ctx) {\n  const { code, language = 'javascript' } = ctx.input;\n  \n  if (!code) {\n    throw new Error('Missing required field: code');\n  }\n  \n  if (language !== 'javascript') {\n    throw new Error(`Unsupported language: ${language}. Only javascript is supported.`);\n  }\n  \n  // Validate syntax\n  try {\n    new Function(code);\n  } catch (syntaxError) {\n    return {\n      status: 'syntax_error',\n      error: syntaxError.message,\n      code: code.substring(0, 100) + (code.length > 100 ? '...' : '')\n    };\n  }\n  \n  // Execute in isolated context\n  const sandbox = {\n    console: ctx.console,\n    Math,\n    JSON,\n    Date,\n    Array,\n    Object,\n    String,\n    Number,\n    Boolean\n  };\n  \n  let result, error;\n  const start = Date.now();\n  \n  try {\n    const fn = new Function('sandbox', `\n      with (sandbox) {\n        return (async () => {\n          ${code}\n        })();\n      }\n    `);\n    result = await fn(sandbox);\n  } catch (e) {\n    error = {\n      message: e.message,\n      stack: e.stack,\n      name: e.name\n    };\n  }\n  \n  const duration = Date.now() - start;\n  \n  return {\n    status: error ? 'error' : 'success',\n    result: error ? null : result,\n    error: error || null,\n    duration_ms: duration,\n    language,\n    code_length: code.length\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.891Z"},"curr_hash":"b3:31aa2898b9f94e3333748194cb1808e13244969e5a82fa5575da4d927b874e76"}
{"id":"00000000-0000-4000-8000-000000000002","seq":3,"entity_type":"function","who":"system","did":"defined","this":"function.observer_bot_kernel","at":"2025-11-04T08:33:30.892Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"observer_bot_kernel","description":"Observes timeline for completed executions and schedules requests for GPT processing","code":"globalThis.default = async function observeTimeline(ctx) {\n  const { client } = ctx;\n  const { lookback_minutes = 60, limit = 10 } = ctx.input || {};\n  \n  // Query recent complete executions without scheduled requests\n  const cutoff = new Date(Date.now() - lookback_minutes * 60000).toISOString();\n  \n  const { rows: executions } = await client.query(`\n    SELECT e.id, e.parent_id, e.at, e.output, e.owner_id, e.tenant_id, e.visibility\n    FROM ledger.visible_timeline e\n    WHERE e.entity_type = 'execution'\n      AND e.status = 'complete'\n      AND e.at > $1\n      AND NOT EXISTS (\n        SELECT 1 FROM ledger.universal_registry r\n        WHERE r.entity_type = 'request'\n          AND r.parent_id = e.id\n          AND r.status = 'scheduled'\n          AND r.is_deleted = false\n      )\n    ORDER BY e.at DESC\n    LIMIT $2\n  `, [cutoff, limit]);\n  \n  console.log(`Found ${executions.length} executions needing request scheduling`);\n  \n  const scheduled = [];\n  \n  for (const exec of executions) {\n    try {\n      // Insert request:scheduled span (idempotency enforced by unique index)\n      const requestId = require('crypto').randomUUID();\n      \n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, parent_id, status, owner_id, tenant_id, visibility, metadata)\n        VALUES ($1, 0, 'request', $2, 'scheduled', 'request', NOW(), $3, 'scheduled', $4, $5, $6, $7)\n      `, [\n        requestId,\n        'system:observer',\n        exec.id,\n        exec.owner_id,\n        exec.tenant_id,\n        exec.visibility,\n        JSON.stringify({ source: 'observer', execution_id: exec.id })\n      ]);\n      \n      scheduled.push({\n        request_id: requestId,\n        execution_id: exec.id,\n        execution_at: exec.at\n      });\n      \n      console.log(`Scheduled request ${requestId} for execution ${exec.id}`);\n    } catch (err) {\n      // Unique constraint violation = already scheduled (idempotent)\n      if (err.code === '23505') {\n        console.log(`Request already scheduled for execution ${exec.id} (idempotent)`);\n      } else {\n        console.error(`Failed to schedule request for execution ${exec.id}:`, err.message);\n      }\n    }\n  }\n  \n  return {\n    status: 'complete',\n    observed: executions.length,\n    scheduled: scheduled.length,\n    requests: scheduled\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.892Z"},"curr_hash":"b3:a6afc63be9a7bbebd4fa8d216dbc0abf85d74d94f62ad964eff4abf7e919ed93"}
{"id":"00000000-0000-4000-8000-000000000003","seq":3,"entity_type":"function","who":"system","did":"defined","this":"function.request_worker_kernel","at":"2025-11-04T08:33:30.892Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"request_worker_kernel","description":"Processes scheduled requests by determining provider and calling provider_exec_kernel","code":"globalThis.default = async function processRequests(ctx) {\n  const { client } = ctx;\n  const { limit = 5 } = ctx.input || {};\n  \n  // Query scheduled requests\n  const { rows: requests } = await client.query(`\n    SELECT id, parent_id, at, metadata, owner_id, tenant_id, visibility\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'request' AND status = 'scheduled'\n    ORDER BY at ASC\n    LIMIT $1\n  `, [limit]);\n  \n  console.log(`Found ${requests.length} scheduled requests to process`);\n  \n  const processed = [];\n  \n  for (const req of requests) {\n    try {\n      // Update status to queued (new span with incremented seq)\n      const { rows: currentSeq } = await client.query(\n        'SELECT COALESCE(MAX(seq), -1) as max_seq FROM ledger.universal_registry WHERE id = $1',\n        [req.id]\n      );\n      const nextSeq = currentSeq[0].max_seq + 1;\n      \n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, parent_id, status, owner_id, tenant_id, visibility, metadata)\n        VALUES ($1, $2, 'request', $3, 'queued', 'request', NOW(), $4, 'queued', $5, $6, $7, $8)\n      `, [req.id, nextSeq, 'system:worker', req.parent_id, req.owner_id, req.tenant_id, req.visibility, req.metadata]);\n      \n      // Fetch parent execution to determine provider\n      const { rows: execRows } = await client.query(\n        'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = \\'execution\\' LIMIT 1',\n        [req.parent_id]\n      );\n      \n      const providerId = execRows[0]?.metadata?.provider_id || 'openai-gpt4';\n      \n      // For now, just log intent to call provider (full implementation needs HTTP client)\n      console.log(`Request ${req.id} would call provider_exec_kernel with provider: ${providerId}`);\n      \n      processed.push({\n        request_id: req.id,\n        status: 'queued',\n        provider_id: providerId,\n        next_action: 'call_provider_exec_kernel'\n      });\n      \n    } catch (err) {\n      console.error(`Failed to process request ${req.id}:`, err.message);\n    }\n  }\n  \n  return {\n    status: 'complete',\n    found: requests.length,\n    processed: processed.length,\n    results: processed\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.892Z"},"curr_hash":"b3:9b6cea53aed87c5a158c8452bfa2d6fcfe92bd6b6d96f510a42c050e3cf88035"}
{"id":"00000000-0000-4000-8000-000000000004","seq":3,"entity_type":"function","who":"system","did":"defined","this":"function.policy_agent_kernel","at":"2025-11-04T08:33:30.893Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"policy_agent_kernel","description":"Evaluates policies from ledger with wildcard matching for action/resource patterns","code":"globalThis.default = async function checkPolicies(ctx) {\n  const { client, env } = ctx;\n  const { action, resource, request_id } = ctx.input;\n  \n  if (!action || !resource) {\n    return { allowed: false, reason: 'Missing required fields: action, resource' };\n  }\n  \n  const userId = env.userId;\n  const tenantId = env.tenantId;\n  \n  console.log(`Checking policies for user=${userId}, tenant=${tenantId}, action=${action}, resource=${resource}`);\n  \n  // Wildcard matching helper (glob to regex)\n  function matchPattern(pattern, value) {\n    if (!pattern || pattern === '*') return true;\n    if (pattern === value) return true;\n    \n    // Convert glob to regex: function/* â†’ ^function\\/.*$\n    const regexPattern = pattern\n      .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n      .replace(/\\*/g, '.*');\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(value);\n  }\n  \n  // Fetch active policies from ledger\n  const { rows: policies } = await client.query(`\n    SELECT id, name, metadata\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'policy'\n      AND status = 'active'\n      AND (visibility = 'public' OR tenant_id = $1)\n    ORDER BY at DESC\n  `, [tenantId]);\n  \n  console.log(`Found ${policies.length} policies to evaluate`);\n  \n  if (policies.length === 0) {\n    return {\n      allowed: false,\n      reason: 'No policies found - default deny',\n      policies_checked: 0\n    };\n  }\n  \n  // Evaluate each policy (deny takes precedence)\n  let lastMatch = null;\n  \n  for (const policy of policies) {\n    const meta = policy.metadata || {};\n    const rules = meta.rules || [];\n    \n    for (const rule of rules) {\n      // Match action pattern with wildcards\n      if (rule.action && !matchPattern(rule.action, action)) {\n        continue;\n      }\n      \n      // Match resource pattern with wildcards\n      if (rule.resource && !matchPattern(rule.resource, resource)) {\n        continue;\n      }\n      \n      console.log(`Matched rule: action=${rule.action}, resource=${rule.resource}, effect=${rule.effect}`);\n      \n      // DENY takes immediate precedence (security first)\n      if (rule.effect === 'deny') {\n        return {\n          allowed: false,\n          reason: `Denied by policy: ${policy.name} (${policy.id})`,\n          policy_id: policy.id,\n          rule: rule\n        };\n      }\n      \n      // Track allow rule (continue checking for deny)\n      if (rule.effect === 'allow') {\n        lastMatch = {\n          allowed: true,\n          reason: `Allowed by policy: ${policy.name} (${policy.id})`,\n          policy_id: policy.id,\n          rule: rule\n        };\n      }\n    }\n  }\n  \n  // Return allow if found, otherwise deny\n  if (lastMatch) {\n    return lastMatch;\n  }\n  \n  return {\n    allowed: false,\n    reason: 'No matching policy found - default deny',\n    policies_checked: policies.length\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.893Z"},"curr_hash":"b3:9e174637b80d60394efdb7e7c28848d089fe26911cb979cbb8245cbdd941f544"}
{"id":"00000000-0000-4000-8000-000000000005","seq":2,"entity_type":"function","who":"system","did":"defined","this":"function.provider_exec_kernel","at":"2025-11-04T08:33:30.894Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"provider_exec_kernel","description":"Executes LLM API calls to external providers (OpenAI, Anthropic) and records metrics","code":"globalThis.default = async function callProvider(ctx) {\n  const { client } = ctx;\n  const { provider_id, prompt, messages, model, max_tokens = 1000, temperature = 0.7 } = ctx.input;\n  \n  if (!provider_id) {\n    throw new Error('Missing required field: provider_id');\n  }\n  \n  // Fetch provider configuration from ledger\n  const { rows: providerRows } = await client.query(`\n    SELECT id, name, metadata\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'provider' AND id = $1\n    ORDER BY at DESC LIMIT 1\n  `, [provider_id]);\n  \n  if (providerRows.length === 0) {\n    throw new Error(`Provider not found: ${provider_id}`);\n  }\n  \n  const provider = providerRows[0];\n  const config = provider.metadata || {};\n  const apiUrl = config.api_url;\n  const apiKey = config.api_key || process.env[config.api_key_env] || process.env.OPENAI_API_KEY;\n  \n  if (!apiUrl || !apiKey) {\n    throw new Error(`Provider ${provider.name} missing api_url or api_key`);\n  }\n  \n  console.log(`Calling provider: ${provider.name} (${provider_id})`);\n  \n  // Prepare request body based on provider type\n  let requestBody;\n  if (config.type === 'openai') {\n    requestBody = {\n      model: model || config.default_model || 'gpt-4',\n      messages: messages || [{ role: 'user', content: prompt }],\n      max_tokens,\n      temperature\n    };\n  } else if (config.type === 'anthropic') {\n    requestBody = {\n      model: model || config.default_model || 'claude-3-opus-20240229',\n      messages: messages || [{ role: 'user', content: prompt }],\n      max_tokens,\n      temperature\n    };\n  } else {\n    throw new Error(`Unsupported provider type: ${config.type}`);\n  }\n  \n  const start = Date.now();\n  let response, error;\n  \n  try {\n    // Note: In Lambda Node.js, use https module or fetch (Node 18+)\n    // For demo, simulating successful response\n    console.log('Making HTTP request to:', apiUrl);\n    console.log('Request body:', JSON.stringify(requestBody, null, 2));\n    \n    // TODO: Replace with actual fetch() call when running in Node 18+\n    // const res = await fetch(apiUrl, {\n    //   method: 'POST',\n    //   headers: {\n    //     'Content-Type': 'application/json',\n    //     'Authorization': `Bearer ${apiKey}`\n    //   },\n    //   body: JSON.stringify(requestBody)\n    // });\n    // response = await res.json();\n    \n    // Simulated response for now\n    response = {\n      id: 'sim-' + require('crypto').randomUUID(),\n      model: requestBody.model,\n      choices: [{\n        message: {\n          role: 'assistant',\n          content: '[SIMULATED] This is a simulated LLM response. Actual HTTP call would go here.'\n        },\n        finish_reason: 'stop'\n      }],\n      usage: {\n        prompt_tokens: 50,\n        completion_tokens: 30,\n        total_tokens: 80\n      }\n    };\n    \n  } catch (e) {\n    error = {\n      message: e.message,\n      stack: e.stack\n    };\n  }\n  \n  const duration = Date.now() - start;\n  \n  // Record metric span\n  await client.query(`\n    INSERT INTO ledger.universal_registry\n      (id, seq, entity_type, who, did, this, at, status, duration_ms, metadata, owner_id, tenant_id, visibility)\n    VALUES ($1, 0, 'metric', 'system:provider', 'measured', 'llm_call', NOW(), $2, $3, $4, 'system', 'system', 'private')\n  `, [\n    require('crypto').randomUUID(),\n    error ? 'error' : 'complete',\n    duration,\n    JSON.stringify({\n      provider_id,\n      provider_name: provider.name,\n      model: requestBody.model,\n      tokens: response?.usage || {},\n      error: error || null\n    })\n  ]);\n  \n  if (error) {\n    throw new Error(`Provider call failed: ${error.message}`);\n  }\n  \n  return {\n    status: 'success',\n    provider: provider.name,\n    model: requestBody.model,\n    response: response.choices[0].message.content,\n    usage: response.usage,\n    duration_ms: duration\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/01-kernels.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.894Z"},"curr_hash":"b3:18493707f485d9c1d46c87d3e1e20665a54f8c45cee163beb64d1d3f3523d62d"}
{"id":"00000000-0000-4000-8000-000000000006","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.prompt_fetch_kernel","at":"2025-11-04T08:33:30.895Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"prompt_fetch_kernel","description":"Fetches prompts from ledger by ID or tags and interpolates variables","code":"globalThis.default = async function fetchPrompt(ctx) {\n  const { client } = ctx;\n  const { prompt_id, tags, variables } = ctx.input;\n  \n  if (!prompt_id && !tags) {\n    throw new Error('Missing required field: prompt_id or tags');\n  }\n  \n  let query, params;\n  \n  if (prompt_id) {\n    // Fetch by ID\n    query = `\n      SELECT id, name, description, metadata\n      FROM ledger.visible_timeline\n      WHERE entity_type = 'prompt' AND id = $1\n      ORDER BY at DESC LIMIT 1\n    `;\n    params = [prompt_id];\n  } else {\n    // Fetch by tags (match any)\n    query = `\n      SELECT id, name, description, metadata\n      FROM ledger.visible_timeline\n      WHERE entity_type = 'prompt'\n        AND status = 'active'\n        AND metadata->'tags' ?| $1\n      ORDER BY at DESC\n      LIMIT 10\n    `;\n    params = [tags];\n  }\n  \n  const { rows: prompts } = await client.query(query, params);\n  \n  if (prompts.length === 0) {\n    throw new Error(`No prompts found for ${prompt_id ? 'id: ' + prompt_id : 'tags: ' + tags.join(', ')}`);\n  }\n  \n  console.log(`Found ${prompts.length} prompt(s)`);\n  \n  // Interpolate variables in template\n  function interpolate(template, vars) {\n    if (!vars) return template;\n    \n    let result = template;\n    for (const [key, value] of Object.entries(vars)) {\n      const regex = new RegExp(`\\\\{\\\\{${key}\\\\}\\\\}`, 'g');\n      result = result.replace(regex, String(value));\n    }\n    return result;\n  }\n  \n  // Process each prompt\n  const results = prompts.map(p => {\n    const meta = p.metadata || {};\n    const template = meta.template || '';\n    const interpolated = interpolate(template, variables);\n    \n    return {\n      id: p.id,\n      name: p.name,\n      description: p.description,\n      tags: meta.tags || [],\n      variables_expected: meta.variables || [],\n      variables_provided: variables ? Object.keys(variables) : [],\n      template_original: template,\n      template_interpolated: interpolated\n    };\n  });\n  \n  // Return first if fetched by ID, all if by tags\n  return prompt_id ? results[0] : results;\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/06-prompt-helper.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.895Z"},"curr_hash":"b3:8d5eea9728dc3c134db643dbccc97d5e5677ea3cd924e3acc440f073cd3150ab"}
{"id":"00000000-0000-4000-8000-000000000007","seq":3,"entity_type":"function","who":"system","did":"defined","this":"function.memory_store_kernel","at":"2025-11-04T08:33:30.896Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"memory_store_kernel","description":"Stores and retrieves memory spans (ledger-only, Blueprint4-compliant)","code":"globalThis.default = async function memoryStore(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { action, memory_type, content, tags, search_query, limit = 10, session_id, sensitivity } = ctx.input || {};\n  \n  if (!action) {\n    throw new Error('Missing required field: action (store|search|list)');\n  }\n  \n  // ACTION: STORE\n  if (action === 'store') {\n    if (!content) {\n      throw new Error('Missing required field: content');\n    }\n    \n    const memoryId = crypto.randomUUID();\n    const memorySpan = {\n      id: memoryId,\n      seq: 0,\n      entity_type: 'memory',\n      who: ctx.env.APP_USER_ID || 'system',\n      did: 'stored',\n      this: 'memory',\n      at: now(),\n      status: 'active',\n      owner_id: ctx.env.APP_USER_ID || 'system',\n      tenant_id: ctx.env.APP_TENANT_ID || 'system',\n      visibility: 'private',\n      metadata: {\n        layer: memory_type || 'local',\n        type: 'note',\n        content,\n        tags: tags || [],\n        sensitivity: sensitivity || 'internal',\n        session_id: session_id || null,\n        stored_at: Date.now()\n      }\n    };\n    \n    await insertSpan(memorySpan);\n    \n    return {\n      ok: true,\n      status: 'stored',\n      memory_id: memoryId,\n      memory_type: memory_type || 'local',\n      content_length: content.length,\n      tags: tags || []\n    };\n  }\n  \n  // ACTION: SEARCH\n  if (action === 'search') {\n    if (!search_query) {\n      throw new Error('Missing required field: search_query');\n    }\n    \n    const searchPattern = '%' + search_query + '%';\n    const { rows: memories } = await sql(\n      `SELECT id, at, metadata\n       FROM ledger.visible_timeline\n       WHERE entity_type = 'memory'\n         AND status = 'active'\n         AND (metadata->>'content' ILIKE $1 OR EXISTS (\n           SELECT 1 FROM jsonb_array_elements_text(metadata->'tags') tag\n           WHERE tag ILIKE $1\n         ))\n       ORDER BY at DESC\n       LIMIT $2`,\n      [searchPattern, limit]\n    );\n    \n    return {\n      ok: true,\n      status: 'found',\n      query: search_query,\n      count: memories.length,\n      memories: memories.map(m => ({\n        id: m.id,\n        stored_at: m.at,\n        content: m.metadata.content,\n        tags: m.metadata.tags || [],\n        memory_type: m.metadata.layer\n      }))\n    };\n  }\n  \n  // ACTION: LIST\n  if (action === 'list') {\n    const { rows: memories } = await sql(\n      `SELECT id, at, metadata\n       FROM ledger.visible_timeline\n       WHERE entity_type = 'memory'\n         AND status = 'active'\n       ORDER BY at DESC\n       LIMIT $1`,\n      [limit]\n    );\n    \n    return {\n      ok: true,\n      status: 'listed',\n      count: memories.length,\n      memories: memories.map(m => ({\n        id: m.id,\n        stored_at: m.at,\n        content_preview: (m.metadata.content || '').substring(0, 100) + '...',\n        tags: m.metadata.tags || [],\n        memory_type: m.metadata.layer\n      }))\n    };\n  }\n  \n  throw new Error(`Unknown action: ${action}. Use store|search|list`);\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/07-memory-kernel.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.896Z"},"curr_hash":"b3:f008d1fa44b0db84df34959e6d96152a7583f94ba65f44d298675231b1b099ab"}
{"id":"00000000-0000-4000-8000-000000000008","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.app_enrollment_kernel","at":"2025-11-04T08:33:30.897Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"app_enrollment_kernel","description":"Handles app enrollment, device registration, and key management","code":"globalThis.default = async function appEnrollment(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { action, app_name, app_version, device_fingerprint, pubkey, tenant_id, app_id } = ctx.input || {};\n  \n  if (!action) {\n    throw new Error('Missing required field: action (enroll|register_device|get_manifest)');\n  }\n  \n  // ACTION: ENROLL - Register new app/device\n  if (action === 'enroll') {\n    if (!app_name || !pubkey || !device_fingerprint) {\n      throw new Error('Missing required fields: app_name, pubkey, device_fingerprint');\n    }\n    \n    const appId = crypto.randomUUID();\n    const deviceId = crypto.randomUUID();\n    const userId = ctx.env.APP_USER_ID || 'system';\n    const tenantIdResolved = tenant_id || ctx.env.APP_TENANT_ID || 'system';\n    \n    // Create app registration span\n    const appSpan = {\n      id: appId,\n      seq: 0,\n      entity_type: 'app_registration',\n      who: 'edge:enrollment',\n      did: 'enrolled',\n      this: 'app',\n      at: now(),\n      status: 'active',\n      owner_id: userId,\n      tenant_id: tenantIdResolved,\n      visibility: 'private',\n      metadata: {\n        app_name,\n        app_version: app_version || '1.0.0',\n        device_fingerprint,\n        pubkey,\n        device_id: deviceId,\n        enrolled_at: Date.now()\n      }\n    };\n    \n    await insertSpan(appSpan);\n    \n    // Create device registration span\n    const deviceSpan = {\n      id: deviceId,\n      seq: 0,\n      entity_type: 'device',\n      who: 'edge:enrollment',\n      did: 'registered',\n      this: 'device',\n      at: now(),\n      status: 'active',\n      owner_id: userId,\n      tenant_id: tenantIdResolved,\n      visibility: 'private',\n      metadata: {\n        fingerprint: device_fingerprint,\n        pubkey,\n        app_id: appId,\n        app_name,\n        registered_at: Date.now()\n      }\n    };\n    \n    await insertSpan(deviceSpan);\n    \n    // Fetch latest manifest for this tenant\n    const { rows: manifestRows } = await sql(\n      `SELECT id, metadata FROM ledger.visible_timeline\n       WHERE entity_type = 'manifest'\n       ORDER BY at DESC, seq DESC\n       LIMIT 1`,\n      []\n    );\n    \n    const manifest = manifestRows[0] || { metadata: {} };\n    \n    return {\n      ok: true,\n      status: 'enrolled',\n      app_id: appId,\n      device_id: deviceId,\n      tenant_id: tenantIdResolved,\n      owner_id: userId,\n      manifest: manifest.metadata,\n      message: 'App enrolled successfully. Store app_id and device_id securely.'\n    };\n  }\n  \n  // ACTION: REGISTER_DEVICE - Register additional device for existing app\n  if (action === 'register_device') {\n    if (!app_id || !device_fingerprint || !pubkey) {\n      throw new Error('Missing required fields: app_id, device_fingerprint, pubkey');\n    }\n    \n    // Verify app exists\n    const { rows: appRows } = await sql(\n      `SELECT id, metadata FROM ledger.visible_timeline\n       WHERE id = $1 AND entity_type = 'app_registration'\n       ORDER BY at DESC, seq DESC\n       LIMIT 1`,\n      [app_id]\n    );\n    \n    if (appRows.length === 0) {\n      throw new Error('App not found. Please enroll first.');\n    }\n    \n    const app = appRows[0];\n    const deviceId = crypto.randomUUID();\n    \n    const deviceSpan = {\n      id: deviceId,\n      seq: 0,\n      entity_type: 'device',\n      who: 'edge:enrollment',\n      did: 'registered',\n      this: 'device',\n      at: now(),\n      status: 'active',\n      owner_id: app.owner_id,\n      tenant_id: app.tenant_id,\n      visibility: 'private',\n      metadata: {\n        fingerprint: device_fingerprint,\n        pubkey,\n        app_id: app_id,\n        app_name: app.metadata.app_name,\n        registered_at: Date.now()\n      }\n    };\n    \n    await insertSpan(deviceSpan);\n    \n    return {\n      ok: true,\n      status: 'device_registered',\n      device_id: deviceId,\n      app_id: app_id,\n      message: 'Device registered successfully'\n    };\n  }\n  \n  // ACTION: GET_MANIFEST - Get current manifest for app\n  if (action === 'get_manifest') {\n    if (!app_id) {\n      throw new Error('Missing required field: app_id');\n    }\n    \n    // Verify app exists and get tenant context\n    const { rows: appRows } = await sql(\n      `SELECT tenant_id FROM ledger.visible_timeline\n       WHERE id = $1 AND entity_type = 'app_registration'\n       ORDER BY at DESC, seq DESC\n       LIMIT 1`,\n      [app_id]\n    );\n    \n    if (appRows.length === 0) {\n      throw new Error('App not found');\n    }\n    \n    const appTenant = appRows[0].tenant_id;\n    \n    // Get latest manifest\n    const { rows: manifestRows } = await sql(\n      `SELECT id, name, metadata, at FROM ledger.visible_timeline\n       WHERE entity_type = 'manifest'\n         AND (tenant_id = $1 OR visibility = 'public')\n       ORDER BY at DESC, seq DESC\n       LIMIT 1`,\n      [appTenant]\n    );\n    \n    if (manifestRows.length === 0) {\n      throw new Error('No manifest available');\n    }\n    \n    const manifest = manifestRows[0];\n    \n    return {\n      ok: true,\n      status: 'manifest_fetched',\n      manifest: {\n        id: manifest.id,\n        name: manifest.name,\n        updated_at: manifest.at,\n        policies: manifest.metadata\n      }\n    };\n  }\n  \n  throw new Error(`Unknown action: ${action}. Use enroll|register_device|get_manifest`);\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/08-enrollment-kernel.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.897Z"},"curr_hash":"b3:ea4f563ba973f72742d48c8ab9074253a6310770e06e3ce2ea6bf3e557b17135"}
{"id":"c0c0c0c0-0000-4000-8000-bldp00000001","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.build_prompt_kernel","at":"2025-11-04T08:33:30.899Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"build_prompt_kernel","description":"Builds prompt from variant blocks, computes compiled_hash, emits prompt_build span","code":"globalThis.default = async function buildPrompt(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { variant_id, variables = {} } = ctx.input || {};\n  \n  if (!variant_id) {\n    throw new Error('Missing required field: variant_id');\n  }\n  \n  // 1. Fetch prompt_variant by ID\n  const variantResult = await sql(\n    'SELECT * FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC, seq DESC LIMIT 1',\n    [variant_id, 'prompt_variant']\n  );\n  const variantRows = variantResult.rows;\n  \n  if (variantRows.length === 0) {\n    throw new Error(`Prompt variant not found: ${variant_id}`);\n  }\n  \n  const variant = variantRows[0];\n  const variantMeta = variant.metadata || {};\n  const blockIds = variantMeta.block_ids || [];\n  const variantVars = variantMeta.vars || {};\n  \n  // Merge variables: variant defaults + input overrides\n  const mergedVars = { ...variantVars, ...variables };\n  \n  // 2. Fetch prompt_blocks by block_ids\n  if (blockIds.length === 0) {\n    throw new Error('Variant has no block_ids');\n  }\n  \n  const blockResult = await sql(\n    'SELECT id, content, metadata, \"when\" FROM ledger.visible_timeline WHERE entity_type = $1 AND id = ANY($2) AND status = $3 ORDER BY \"when\" DESC',\n    ['prompt_block', blockIds, 'active']\n  );\n  const blockRows = blockResult.rows;\n  \n  if (blockRows.length === 0) {\n    throw new Error('No active prompt blocks found for variant');\n  }\n  \n  // 3. Sort blocks by priority (Doctrine > Product > App > Task)\n  // Priority is stored in metadata.priority (higher = more important)\n  blockRows.sort((a, b) => {\n    const priA = (a.metadata?.priority || 0);\n    const priB = (b.metadata?.priority || 0);\n    if (priA !== priB) return priB - priA; // Higher priority first\n    // If same priority, use timestamp (newer first)\n    return new Date(b.when || b.at) - new Date(a.when || a.at);\n  });\n  \n  // 4. Interpolate variables in block content\n  function interpolate(template, vars) {\n    if (!template || !vars) return template || '';\n    let result = String(template);\n    for (const [key, value] of Object.entries(vars)) {\n      const regex = new RegExp(`\\\\{\\\\{${key}\\\\}\\\\}`, 'g');\n      result = result.replace(regex, String(value));\n    }\n    return result;\n  }\n  \n  // Compose blocks (higher priority first, so later blocks override earlier)\n  const blockContents = blockRows.map(block => {\n    const content = block.content || '';\n    return interpolate(content, mergedVars);\n  });\n  \n  // Join with double newline\n  const systemPrompt = blockContents.join('\\n\\n');\n  \n  // 5. Compute BLAKE3 compiled_hash of final system_prompt\n  const promptBytes = new TextEncoder().encode(systemPrompt);\n  const hashBytes = crypto.blake3(promptBytes);\n  const compiledHash = crypto.hex(hashBytes);\n  \n  // 6. Emit prompt_build span\n  const buildId = crypto.randomUUID();\n  const buildSpan = {\n    id: buildId,\n    seq: 0,\n    entity_type: 'prompt_build',\n    who: 'edge:build_prompt',\n    did: 'built',\n    this: 'prompt.build',\n    at: now(),\n    status: 'complete',\n    owner_id: variant.owner_id,\n    tenant_id: variant.tenant_id,\n    visibility: variant.visibility || 'private',\n    related_to: [variant_id],\n    output: {\n      system_prompt: systemPrompt,\n      compiled_hash: compiledHash,\n      variant_id: variant_id,\n      block_count: blockRows.length,\n      variables_used: Object.keys(mergedVars)\n    },\n    metadata: {\n      block_ids: blockIds,\n      variables: mergedVars\n    }\n  };\n  \n  await insertSpan(buildSpan);\n  \n  return {\n    ok: true,\n    build_id: buildId,\n    system_prompt: systemPrompt,\n    compiled_hash: compiledHash,\n    block_count: blockRows.length\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/09-prompt-build.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.899Z"},"curr_hash":"b3:2d6e78553751c50097536211c74658803f23fc9da49d11818d9a0ac9772e9a37"}
{"id":"c0c0c0c0-0000-4000-8000-runp00000001","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.prompt_runner_kernel","at":"2025-11-04T08:33:30.900Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"prompt_runner_kernel","description":"Runs prompt with variant, calls provider, records telemetry, emits prompt_run span","code":"globalThis.default = async function runPrompt(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { variant_id, compiled_hash, user_input, context, provider_id, model } = ctx.input || {};\n  \n  if (!user_input) {\n    throw new Error('Missing required field: user_input');\n  }\n  \n  const traceId = crypto.randomUUID();\n  const startTime = Date.now();\n  let systemPrompt = null;\n  let actualCompiledHash = compiled_hash;\n  \n  // 1. Get system prompt (from build or fetch latest build)\n  if (variant_id && !compiled_hash) {\n    // Fetch latest prompt_build for this variant\n    const buildResult = await sql(\n      'SELECT output FROM ledger.visible_timeline WHERE entity_type = $1 AND related_to @> ARRAY[$2]::uuid[] ORDER BY \"when\" DESC LIMIT 1',\n      ['prompt_build', variant_id]\n    );\n    \n    if (buildResult.rows.length > 0) {\n      const build = buildResult.rows[0];\n      systemPrompt = build.output?.system_prompt;\n      actualCompiledHash = build.output?.compiled_hash;\n    }\n  }\n  \n  // If no build found, call build_prompt_kernel\n  if (!systemPrompt && variant_id) {\n    // For now, we'll fetch blocks directly (in production, call build kernel)\n    const variantResult = await sql(\n      'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [variant_id, 'prompt_variant']\n    );\n    \n    if (variantResult.rows.length > 0) {\n      const blockIds = variantResult.rows[0].metadata?.block_ids || [];\n      if (blockIds.length > 0) {\n        const blockResult = await sql(\n          'SELECT content, metadata FROM ledger.visible_timeline WHERE entity_type = $1 AND id = ANY($2) AND status = $3 ORDER BY (metadata->>\\'priority\\')::int DESC NULLS LAST',\n          ['prompt_block', blockIds, 'active']\n        );\n        \n        const blocks = blockResult.rows.map(r => r.content || '').filter(Boolean);\n        systemPrompt = blocks.join('\\n\\n');\n        \n        // Compute hash\n        const promptBytes = new TextEncoder().encode(systemPrompt);\n        const hashBytes = crypto.blake3(promptBytes);\n        actualCompiledHash = crypto.hex(hashBytes);\n      }\n    }\n  }\n  \n  if (!systemPrompt) {\n    throw new Error('Could not build system prompt - missing variant_id or compiled_hash');\n  }\n  \n  // 2. Assemble messages array\n  const messages = [\n    { role: 'system', content: systemPrompt }\n  ];\n  \n  if (context) {\n    messages.push({ role: 'system', content: `CONTEXT:\\n${String(context)}` });\n  }\n  \n  messages.push({ role: 'user', content: String(user_input) });\n  \n  // 3. Call provider_exec_kernel\n  const defaultProviderId = provider_id || '00000000-0000-4000-8000-000000000005';\n  \n  // Fetch provider_exec_kernel\n  const providerKernelResult = await sql(\n    'SELECT code FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n    ['00000000-0000-4000-8000-000000000005', 'function']\n  );\n  \n  let providerResponse = null;\n  let providerError = null;\n  let providerModel = model || 'gpt-4';\n  let toolUseCount = 0;\n  \n  if (providerKernelResult.rows.length > 0) {\n    try {\n      // Execute provider kernel with messages\n      const providerCtx = {\n        ...ctx,\n        input: {\n          provider_id: defaultProviderId,\n          messages: messages,\n          model: providerModel,\n          temperature: 0.2\n        }\n      };\n      \n      const providerCode = providerKernelResult.rows[0].code;\n      const providerFn = new Function('ctx', `${providerCode}\\nreturn (typeof globalThis.default !== 'undefined' ? globalThis.default : main);`)(providerCtx);\n      \n      if (typeof providerFn === 'function') {\n        providerResponse = await providerFn(providerCtx);\n        providerModel = providerResponse.model || providerModel;\n      }\n    } catch (e) {\n      providerError = { message: e.message, stack: e.stack };\n    }\n  }\n  \n  const latencyMs = Date.now() - startTime;\n  \n  // 4. Parse response and ensure schema compliance\n  let responseText = providerResponse?.response || providerResponse?.choices?.[0]?.message?.content || '';\n  let confidence = 0.8; // Default confidence\n  \n  // Try to parse as JSON schema\n  try {\n    const parsed = typeof responseText === 'string' ? JSON.parse(responseText) : responseText;\n    if (parsed.text) {\n      responseText = parsed.text;\n      confidence = parsed.confidence || 0.8;\n    }\n  } catch (e) {\n    // Not JSON, use as-is\n  }\n  \n  // 5. Emit prompt_run span with telemetry\n  const runId = crypto.randomUUID();\n  const runSpan = {\n    id: runId,\n    seq: 0,\n    entity_type: 'prompt_run',\n    who: 'edge:prompt_runner',\n    did: 'ran',\n    this: 'prompt.run',\n    at: now(),\n    status: providerError ? 'error' : 'complete',\n    owner_id: ctx.env.APP_USER_ID || 'system',\n    tenant_id: ctx.env.APP_TENANT_ID || 'system',\n    visibility: 'private',\n    related_to: variant_id ? [variant_id] : [],\n    input: {\n      variant_id: variant_id || null,\n      compiled_hash: actualCompiledHash,\n      user_input: user_input,\n      context: context || null,\n      provider_id: defaultProviderId\n    },\n    output: {\n      text: responseText,\n      confidence: confidence,\n      model: providerModel,\n      latency_ms: latencyMs,\n      tool_use_count: toolUseCount\n    },\n    error: providerError || null,\n    duration_ms: latencyMs,\n    trace_id: traceId,\n    metadata: {\n      compiled_hash: actualCompiledHash,\n      provider_model: providerModel\n    }\n  };\n  \n  await insertSpan(runSpan);\n  \n  // 6. Return schema-compliant response\n  return {\n    text: responseText,\n    confidence: confidence,\n    follow_up_question: null,\n    actions: [],\n    citations: [],\n    telemetry: {\n      tool_use_count: toolUseCount,\n      latency_ms: latencyMs,\n      model: providerModel,\n      compiled_hash: actualCompiledHash,\n      trace_id: traceId\n    }\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/10-prompt-runner.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.900Z"},"curr_hash":"b3:df3734d1e844cf8c4951ea2dd3646f3295ac55e5e321661e8b520cccd47713c0"}
{"id":"c0c0c0c0-0000-4000-8000-eval00000001","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.prompt_eval_kernel","at":"2025-11-04T08:33:30.901Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"prompt_eval_kernel","description":"Evaluates prompt variants using fixtures (happy+stress), validates constraints, emits eval results","code":"globalThis.default = async function evalPrompt(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { eval_id, variant_id } = ctx.input || {};\n  \n  if (!eval_id && !variant_id) {\n    throw new Error('Missing required field: eval_id or variant_id');\n  }\n  \n  // 1. Load prompt_eval span by ID (or create from variant_id)\n  let evalSpan = null;\n  \n  if (eval_id) {\n    const evalResult = await sql(\n      'SELECT * FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [eval_id, 'prompt_eval']\n    );\n    evalSpan = evalResult.rows[0];\n  }\n  \n  if (!evalSpan && variant_id) {\n    // Try to find eval by prompt_id in metadata\n    const evalResult = await sql(\n      'SELECT * FROM ledger.visible_timeline WHERE entity_type = $1 AND metadata->>\\'prompt_id\\' = (SELECT name FROM ledger.visible_timeline WHERE id = $2 LIMIT 1) ORDER BY \"when\" DESC LIMIT 1',\n      ['prompt_eval', variant_id]\n    );\n    evalSpan = evalResult.rows[0];\n  }\n  \n  if (!evalSpan) {\n    throw new Error('Prompt eval not found');\n  }\n  \n  const evalInput = evalSpan.input || {};\n  const fixtures = evalInput.fixtures || [];\n  const targetVariantId = variant_id || evalSpan.related_to?.[0];\n  \n  if (!targetVariantId) {\n    throw new Error('Could not determine target variant_id');\n  }\n  \n  // 2. Fetch prompt_runner_kernel\n  const runnerResult = await sql(\n    'SELECT code FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n    ['c0c0c0c0-0000-4000-8000-runp00000001', 'function']\n  );\n  \n  if (runnerResult.rows.length === 0) {\n    throw new Error('prompt_runner_kernel not found');\n  }\n  \n  const runnerCode = runnerResult.rows[0].code;\n  const runnerFn = new Function('ctx', `${runnerCode}\\nreturn (typeof globalThis.default !== 'undefined' ? globalThis.default : main);`)(ctx);\n  \n  if (typeof runnerFn !== 'function') {\n    throw new Error('prompt_runner_kernel is not a function');\n  }\n  \n  // 3. Run each fixture through prompt_runner_kernel\n  const results = [];\n  const passFail = { happy: { pass: 0, fail: 0 }, ambiguous: { pass: 0, fail: 0 }, overlong_context: { pass: 0, fail: 0 }, conflicting: { pass: 0, fail: 0 }, tool_unavailable: { pass: 0, fail: 0 } };\n  \n  for (const fixture of fixtures) {\n    const fixtureType = fixture.type || 'happy';\n    let fixtureResult = null;\n    let fixtureError = null;\n    \n    try {\n      // Run fixture through runner\n      const runnerCtx = {\n        ...ctx,\n        input: {\n          variant_id: targetVariantId,\n          user_input: fixture.input,\n          context: fixture.context || null,\n          provider_id: fixture.provider_id || null\n        }\n      };\n      \n      fixtureResult = await runnerFn(runnerCtx);\n    } catch (e) {\n      fixtureError = { message: e.message, stack: e.stack };\n    }\n  \n    // 4. Validate constraints\n    const mustContain = fixture.must_contain || [];\n    const mustError = fixture.must_error || false;\n    \n    let passed = true;\n    const reasons = [];\n    \n    if (mustError) {\n      if (!fixtureError) {\n        passed = false;\n        reasons.push('Expected error but got success');\n      }\n    } else {\n      if (fixtureError) {\n        passed = false;\n        reasons.push(`Unexpected error: ${fixtureError.message}`);\n      } else {\n        const responseText = fixtureResult?.text || JSON.stringify(fixtureResult || '');\n        for (const required of mustContain) {\n          if (!responseText.includes(required)) {\n            passed = false;\n            reasons.push(`Missing required text: ${required}`);\n          }\n        }\n      }\n    }\n    \n    // Update pass/fail counts\n    if (passFail[fixtureType]) {\n      if (passed) {\n        passFail[fixtureType].pass++;\n      } else {\n        passFail[fixtureType].fail++;\n      }\n    }\n    \n    results.push({\n      fixture_type: fixtureType,\n      passed: passed,\n      reasons: reasons,\n      response: fixtureResult,\n      error: fixtureError\n    });\n  }\n  \n  // 5. Emit prompt_eval_result span\n  const evalResultId = crypto.randomUUID();\n  const evalResultSpan = {\n    id: evalResultId,\n    seq: 0,\n    entity_type: 'prompt_eval_result',\n    who: 'edge:prompt_eval',\n    did: 'evaluated',\n    this: 'prompt.eval',\n    at: now(),\n    status: 'complete',\n    owner_id: evalSpan.owner_id,\n    tenant_id: evalSpan.tenant_id,\n    visibility: evalSpan.visibility || 'private',\n    related_to: [eval_id || targetVariantId],\n    input: {\n      eval_id: eval_id,\n      variant_id: targetVariantId,\n      fixture_count: fixtures.length\n    },\n    output: {\n      results: results,\n      pass_fail: passFail,\n      total_fixtures: fixtures.length,\n      total_passed: results.filter(r => r.passed).length,\n      total_failed: results.filter(r => !r.passed).length\n    },\n    metadata: {\n      variant_id: targetVariantId\n    }\n  };\n  \n  await insertSpan(evalResultSpan);\n  \n  return {\n    ok: true,\n    eval_result_id: evalResultId,\n    total_fixtures: fixtures.length,\n    total_passed: results.filter(r => r.passed).length,\n    total_failed: results.filter(r => !r.passed).length,\n    pass_fail: passFail,\n    results: results\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/11-prompt-eval.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.901Z"},"curr_hash":"b3:6a85e515774a6c69c3eba4149fb76ed014220bde516af4215800a07f76954c25"}
{"id":"c0c0c0c0-0000-4000-8000-band00000001","seq":0,"entity_type":"function","who":"system","did":"defined","this":"function.prompt_bandit_kernel","at":"2025-11-04T08:33:30.902Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"prompt_bandit_kernel","description":"Multi-armed bandit selection for prompt variants based on metrics, emits variant selection","code":"globalThis.default = async function selectVariant(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { prompt_family, window_days = 7 } = ctx.input || {};\n  \n  if (!prompt_family) {\n    throw new Error('Missing required field: prompt_family');\n  }\n  \n  // 1. Find all variants in the family\n  const variantsResult = await sql(\n    'SELECT id, name, metadata FROM ledger.visible_timeline WHERE entity_type = $1 AND metadata->>\\'family\\' = $2 AND status = $3 ORDER BY \"when\" DESC',\n    ['prompt_variant', prompt_family, 'active']\n  );\n  \n  const variants = variantsResult.rows;\n  \n  if (variants.length === 0) {\n    throw new Error(`No active variants found for family: ${prompt_family}`);\n  }\n  \n  // 2. Query prompt_run spans for all variants (last window_days)\n  const cutoffDate = new Date(Date.now() - window_days * 24 * 60 * 60 * 1000).toISOString();\n  const variantIds = variants.map(v => v.id);\n  \n  const runsResult = await sql(\n    'SELECT input->>\\'variant_id\\' as variant_id, output, status, \"when\" FROM ledger.visible_timeline WHERE entity_type = $1 AND input->>\\'variant_id\\' = ANY($2) AND \"when\" > $3 ORDER BY \"when\" DESC',\n    ['prompt_run', variantIds, cutoffDate]\n  );\n  \n  const runs = runsResult.rows;\n  \n  // 3. Calculate metrics per variant\n  const variantMetrics = {};\n  \n  for (const variant of variants) {\n    const variantId = variant.id;\n    const variantRuns = runs.filter(r => r.variant_id === variantId);\n    \n    if (variantRuns.length === 0) {\n      variantMetrics[variantId] = {\n        variant_id: variantId,\n        variant_name: variant.name,\n        run_count: 0,\n        avg_confidence: 0.5,\n        avg_latency_ms: 0,\n        error_rate: 0,\n        exploration_score: 1.0 // Higher for variants with fewer runs\n      };\n      continue;\n    }\n    \n    const successfulRuns = variantRuns.filter(r => r.status === 'complete' && r.output);\n    const errorCount = variantRuns.filter(r => r.status === 'error').length;\n    \n    const confidences = successfulRuns.map(r => parseFloat(r.output?.confidence || 0.5));\n    const latencies = successfulRuns.map(r => parseInt(r.output?.latency_ms || 0));\n    \n    const avgConfidence = confidences.length > 0 ? confidences.reduce((a, b) => a + b, 0) / confidences.length : 0.5;\n    const avgLatency = latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0;\n    const errorRate = variantRuns.length > 0 ? errorCount / variantRuns.length : 0;\n    \n    // Exploration bonus: favor variants with fewer runs (epsilon-greedy)\n    const explorationScore = 1.0 / Math.max(1, variantRuns.length);\n    \n    variantMetrics[variantId] = {\n      variant_id: variantId,\n      variant_name: variant.name,\n      run_count: variantRuns.length,\n      avg_confidence: avgConfidence,\n      avg_latency_ms: avgLatency,\n      error_rate: errorRate,\n      exploration_score: explorationScore\n    };\n  }\n  \n  // 4. Multi-armed bandit selection\n  // UCB (Upper Confidence Bound) style: confidence * (1 - error_rate) * exploration_bonus\n  let bestVariantId = null;\n  let bestScore = -Infinity;\n  \n  for (const [variantId, metrics] of Object.entries(variantMetrics)) {\n    // Score = (confidence * (1 - error_rate) * 0.7) + (exploration_score * 0.3)\n    const exploitationScore = metrics.avg_confidence * (1 - metrics.error_rate) * 0.7;\n    const explorationBonus = metrics.exploration_score * 0.3;\n    const totalScore = exploitationScore + explorationBonus;\n    \n    if (totalScore > bestScore) {\n      bestScore = totalScore;\n      bestVariantId = variantId;\n    }\n  }\n  \n  if (!bestVariantId) {\n    // Fallback to first variant\n    bestVariantId = variants[0].id;\n  }\n  \n  const selectedVariant = variants.find(v => v.id === bestVariantId);\n  \n  // 5. Emit prompt_variant_selection span\n  const selectionId = crypto.randomUUID();\n  const selectionSpan = {\n    id: selectionId,\n    seq: 0,\n    entity_type: 'prompt_variant_selection',\n    who: 'edge:prompt_bandit',\n    did: 'selected',\n    this: prompt_family,\n    at: now(),\n    status: 'complete',\n    owner_id: selectedVariant.owner_id,\n    tenant_id: selectedVariant.tenant_id,\n    visibility: selectedVariant.visibility || 'private',\n    related_to: [bestVariantId],\n    input: {\n      prompt_family: prompt_family,\n      window_days: window_days,\n      variant_count: variants.length\n    },\n    output: {\n      current: {\n        id: bestVariantId,\n        name: selectedVariant.name,\n        score: bestScore\n      },\n      metrics: variantMetrics,\n      selection_reason: 'multi_armed_bandit'\n    },\n    metadata: {\n      prompt_family: prompt_family\n    }\n  };\n  \n  await insertSpan(selectionSpan);\n  \n  return {\n    ok: true,\n    selection_id: selectionId,\n    selected_variant: {\n      id: bestVariantId,\n      name: selectedVariant.name,\n      score: bestScore\n    },\n    metrics: variantMetrics,\n    window_days: window_days\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/12-prompt-bandit.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.902Z"},"curr_hash":"b3:c7d45578d71ce549ac5400b49026e17f12900281da3d7587ee4c472f042c7010"}
{"id":"00000000-0000-4000-8000-000000000009","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.memory_upsert_kernel","at":"2025-11-04T08:33:30.903Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"memory_upsert_kernel","description":"Upserts memory spans with optional encryption, schema validation, emits memory + memory_audit spans","code":"globalThis.default = async function upsertMemory(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { layer, type, content, tags, schema_id, sensitivity, ttl_at, session_id } = ctx.input || {};\n  \n  if (!layer || !type || !content) {\n    throw new Error('Missing required fields: layer, type, content');\n  }\n  \n  const userId = ctx.env.APP_USER_ID || 'system';\n  const tenantId = ctx.env.APP_TENANT_ID || 'system';\n  const kmsHex = ctx.env.KMS_HEX || process.env.KMS_HEX;\n  \n  // 1. Validate schema_id if provided\n  if (schema_id) {\n    const schemaResult = await sql(\n      'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [schema_id, 'memory_contract']\n    );\n    \n    if (schemaResult.rows.length === 0) {\n      throw new Error(`Memory schema not found: ${schema_id}`);\n    }\n    \n    // TODO: Validate content against schema JSON schema\n  }\n  \n  // 2. Encrypt content if sensitivity != 'public' and KMS_HEX present\n  let encryptedContent = null;\n  let encryptionIv = null;\n  let encryptionTag = null;\n  let contentToStore = content;\n  \n  if (sensitivity !== 'public' && kmsHex) {\n    try {\n      // Use encryption from ctx\n      const encrypted = await crypto.encryptAES256GCM(\n        typeof content === 'string' ? content : JSON.stringify(content),\n        kmsHex\n      );\n      \n      encryptedContent = encrypted.encrypted;\n      encryptionIv = encrypted.iv;\n      encryptionTag = encrypted.tag;\n      contentToStore = { redacted: true }; // Plaintext not stored\n    } catch (e) {\n      console.error('Encryption failed:', e.message);\n      // Continue without encryption if it fails\n    }\n  }\n  \n  // 3. Build memory span\n  const memoryId = crypto.randomUUID();\n  const memorySpan = {\n    id: memoryId,\n    seq: 0,\n    entity_type: 'memory',\n    who: 'kernel:memory_upsert',\n    did: 'upserted',\n    this: `memory.${type}`,\n    at: now(),\n    status: 'active',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    content: contentToStore,\n    metadata: {\n      layer: layer,\n      type: type,\n      schema_id: schema_id || null,\n      tags: tags || [],\n      sensitivity: sensitivity || 'internal',\n      ttl_at: ttl_at || null,\n      session_id: session_id || null,\n      stored_at: Date.now(),\n      encrypted_content: encryptedContent,\n      encryption_iv: encryptionIv,\n      encryption_tag: encryptionTag\n    }\n  };\n  \n  await insertSpan(memorySpan);\n  \n  // 4. Emit memory_audit span with rolling hash\n  const auditId = crypto.randomUUID();\n  \n  // Compute rolling hash (hash of previous audit + current memory)\n  const prevAuditResult = await sql(\n    'SELECT curr_hash FROM ledger.visible_timeline WHERE entity_type = $1 AND related_to @> ARRAY[$2]::uuid[] ORDER BY \"when\" DESC LIMIT 1',\n    ['memory_audit', memoryId]\n  );\n  \n  const prevHash = prevAuditResult.rows[0]?.curr_hash || null;\n  const auditPayload = {\n    action: 'upsert',\n    memory_id: memoryId,\n    prev_hash: prevHash\n  };\n  \n  const auditHashBytes = crypto.blake3(new TextEncoder().encode(JSON.stringify(auditPayload)));\n  const auditHash = crypto.hex(auditHashBytes);\n  \n  const auditSpan = {\n    id: auditId,\n    seq: 0,\n    entity_type: 'memory_audit',\n    who: 'kernel:memory_upsert',\n    did: 'audited',\n    this: 'memory.audit',\n    at: now(),\n    status: 'complete',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    related_to: [memoryId],\n    input: auditPayload,\n    curr_hash: auditHash,\n    prev_hash: prevHash,\n    metadata: {\n      action: 'upsert',\n      memory_id: memoryId\n    }\n  };\n  \n  await insertSpan(auditSpan);\n  \n  return {\n    ok: true,\n    memory_id: memoryId,\n    audit_id: auditId,\n    encrypted: !!encryptedContent,\n    layer: layer,\n    type: type\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/13-memory-upsert.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.903Z"},"curr_hash":"b3:54e162fc78390051bd337130d6eaf13c25597f0e62df858da680e1379d5f0243"}
{"id":"00000000-0000-4000-8000-000000000010","seq":1,"entity_type":"function","who":"system","did":"defined","this":"function.memory_search_kernel","at":"2025-11-04T08:33:30.904Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"memory_search_kernel","description":"Searches memories with scope ranking (sessionâ†’privateâ†’tenantâ†’public), text/vector search, context budget","code":"globalThis.default = async function searchMemory(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { Q, TOPK = 10, USE_VECTOR = false, session_id, memory_mode = 'on' } = ctx.input || {};\n  \n  if (!Q) {\n    throw new Error('Missing required field: Q (query string)');\n  }\n  \n  const userId = ctx.env.APP_USER_ID || 'system';\n  const tenantId = ctx.env.APP_TENANT_ID || 'system';\n  \n  // 1. Respect memory_mode: off|session-only|on\n  if (memory_mode === 'off') {\n    return {\n      ok: true,\n      hits: [],\n      count: 0,\n      mode: 'off'\n    };\n  }\n  \n  // 2. Scope ranking: session â†’ private â†’ tenant â†’ public\n  const searchPattern = '%' + String(Q).replace(/'/g, \"''\") + '%';\n  \n  // Build queries for each scope (in priority order)\n  const hits = [];\n  const seenIds = new Set();\n  \n  // Session scope (exact session_id match)\n  if (session_id && (memory_mode === 'session-only' || memory_mode === 'on')) {\n    const sessionResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND metadata->>$3 = $4 AND (metadata->>$5 ILIKE $6 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$7) tag WHERE tag ILIKE $6)) ORDER BY at DESC LIMIT $8',\n      ['memory', 'active', 'session_id', session_id, 'content', searchPattern, 'tags', TOPK]\n    );\n    \n    for (const row of sessionResult.rows) {\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 1.0,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'session',\n          scope: 'session',\n          stored_at: row.at\n        });\n      }\n    }\n    \n    if (memory_mode === 'session-only') {\n      return formatResults(hits, Q, TOPK);\n    }\n  }\n  \n  // Private scope (user's own memories)\n  if (hits.length < TOPK) {\n    const privateResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND owner_id = $3 AND visibility = $4 AND (metadata->>$5 IN ($6, $7)) AND (metadata->>$8 ILIKE $9 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$10) tag WHERE tag ILIKE $9)) ORDER BY at DESC LIMIT $11',\n      ['memory', 'active', userId, 'private', 'layer', 'temporary', 'permanent', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of privateResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.8,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'local',\n          scope: 'private',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // Tenant scope\n  if (hits.length < TOPK) {\n    const tenantResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND tenant_id = $3 AND visibility IN ($4, $5) AND (metadata->>$6 ILIKE $7 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$8) tag WHERE tag ILIKE $7)) ORDER BY at DESC LIMIT $9',\n      ['memory', 'active', tenantId, 'tenant', 'public', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of tenantResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.6,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'shared',\n          scope: 'tenant',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // Public scope (if still room)\n  if (hits.length < TOPK) {\n    const publicResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND visibility = $3 AND (metadata->>$4 ILIKE $5 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$6) tag WHERE tag ILIKE $5)) ORDER BY at DESC LIMIT $7',\n      ['memory', 'active', 'public', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of publicResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.4,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'shared',\n          scope: 'public',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // 3. Optional vector search (if USE_VECTOR=true and pgvector available)\n  // TODO: Implement vector similarity search when pgvector is available\n  \n  // 4. Emit memory_search_result span\n  const searchId = crypto.randomUUID();\n  const searchSpan = {\n    id: searchId,\n    seq: 0,\n    entity_type: 'memory_search_result',\n    who: 'kernel:memory_search',\n    did: 'searched',\n    this: 'memory.search',\n    at: now(),\n    status: 'complete',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    input: {\n      query: Q,\n      topk: TOPK,\n      use_vector: USE_VECTOR,\n      session_id: session_id || null,\n      memory_mode: memory_mode\n    },\n    output: {\n      hits: hits,\n      count: hits.length\n    },\n    metadata: {\n      query: Q,\n      hit_count: hits.length\n    }\n  };\n  \n  await insertSpan(searchSpan);\n  \n  return formatResults(hits, Q, TOPK);\n  \n  // Helper functions\n  function extractPreview(row) {\n    const content = row.content || row.metadata?.content || '';\n    if (typeof content === 'string') {\n      return content.substring(0, 160) + (content.length > 160 ? '...' : '');\n    }\n    if (content && content.redacted) {\n      return '[encrypted]';\n    }\n    return JSON.stringify(content || '').substring(0, 160);\n  }\n  \n  function formatResults(hits, query, topk) {\n    return {\n      ok: true,\n      query: query,\n      hits: hits,\n      count: hits.length,\n      topk: topk\n    };\n  }\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/14-memory-search.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.904Z"},"curr_hash":"b3:a0a591b071fee5933b67fafb17935e692f01b0ab9033c697b0d725c4c666db6a"}
{"id":"00000000-0000-4000-8000-000000000015","seq":0,"entity_type":"function","who":"system","did":"defined","this":"function.token_issuer_kernel","at":"2025-11-04T08:33:30.905Z","status":"active","visibility":"public","owner_id":"system","tenant_id":"system","name":"token_issuer_kernel","description":"Issues API tokens, stores only hash in ledger, returns plaintext token once","code":"globalThis.default = async function tokenIssuer(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { tenant_id, app_id, scopes, ttl_hours = 720 } = ctx.input || {};\n  \n  if (!tenant_id || !scopes?.length) {\n    throw new Error('Missing required fields: tenant_id, scopes');\n  }\n  \n  const userId = ctx.env.APP_USER_ID || 'admin';\n  const tenantId = tenant_id;\n  \n  // Get pepper from environment (set via Secrets Manager)\n  const pepper = ctx.env.TOKEN_PEPPER || process.env.TOKEN_PEPPER;\n  if (!pepper) {\n    throw new Error('TOKEN_PEPPER not configured');\n  }\n  \n  // Generate token\n  const prefix = `tok_${tenant_id}_`;\n  const randomBytes = new Uint8Array(24);\n  crypto.getRandomValues(randomBytes);\n  const random = Buffer.from(randomBytes).toString('base64url');\n  const plaintext = prefix + random;\n  \n  // Hash = BLAKE3(plaintext + pepper)\n  const hashInput = new TextEncoder().encode(plaintext + pepper);\n  const hashBytes = crypto.blake3(hashInput);\n  const hashHex = crypto.hex(hashBytes);\n  const hashTag = `b3:${hashHex}`;\n  \n  // Calculate expiration\n  const expiresAt = new Date(Date.now() + (ttl_hours * 3600 * 1000)).toISOString();\n  \n  // Insert token span (hash only, no plaintext)\n  const tokenId = crypto.randomUUID();\n  const tokenSpan = {\n    id: tokenId,\n    seq: 0,\n    entity_type: 'api_token',\n    who: 'kernel:token_issuer',\n    did: 'issued',\n    this: 'security.token',\n    at: now(),\n    status: 'active',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'tenant',\n    metadata: {\n      app_id: app_id || null,\n      token_prefix: prefix,\n      token_hash: hashTag,\n      scopes: scopes,\n      expires_at: expiresAt\n    }\n  };\n  \n  await insertSpan(tokenSpan);\n  \n  // Return plaintext token ONLY ONCE (not stored in ledger)\n  return {\n    ok: true,\n    token: plaintext,\n    tenant_id: tenantId,\n    app_id: app_id || null,\n    scopes: scopes,\n    expires_at: expiresAt,\n    token_id: tokenId\n  };\n};","language":"javascript","runtime":"deno@1.x","metadata":{"source_file":"/Users/voulezvous/Library/Mobile Documents/com~apple~CloudDocs/loglineos-blueprint4/ROW/kernels/15-token-issuer.ndjson","git_sha":"local","git_ref":"refs/heads/main","git_repo":"loglineos-blueprint4","transformed_at":"2025-11-04T08:33:30.905Z"},"curr_hash":"b3:5e360061e39022dfc5ad2d5fe9533c0fcd4f21c4df677afd9cec99ad1d99a118"}
