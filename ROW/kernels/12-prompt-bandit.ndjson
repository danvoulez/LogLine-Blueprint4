{"id":"c0c0c0c0-0000-4000-8000-band00000001","seq":0,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"prompt_bandit_kernel","description":"Multi-armed bandit selection for prompt variants based on metrics, emits variant selection","code":"globalThis.default = async function selectVariant(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { prompt_family, window_days = 7 } = ctx.input || {};\n  \n  if (!prompt_family) {\n    throw new Error('Missing required field: prompt_family');\n  }\n  \n  // 1. Find all variants in the family\n  const variantsResult = await sql(\n    'SELECT id, name, metadata FROM ledger.visible_timeline WHERE entity_type = $1 AND metadata->>\\'family\\' = $2 AND status = $3 ORDER BY \"when\" DESC',\n    ['prompt_variant', prompt_family, 'active']\n  );\n  \n  const variants = variantsResult.rows;\n  \n  if (variants.length === 0) {\n    throw new Error(`No active variants found for family: ${prompt_family}`);\n  }\n  \n  // 2. Query prompt_run spans for all variants (last window_days)\n  const cutoffDate = new Date(Date.now() - window_days * 24 * 60 * 60 * 1000).toISOString();\n  const variantIds = variants.map(v => v.id);\n  \n  const runsResult = await sql(\n    'SELECT input->>\\'variant_id\\' as variant_id, output, status, \"when\" FROM ledger.visible_timeline WHERE entity_type = $1 AND input->>\\'variant_id\\' = ANY($2) AND \"when\" > $3 ORDER BY \"when\" DESC',\n    ['prompt_run', variantIds, cutoffDate]\n  );\n  \n  const runs = runsResult.rows;\n  \n  // 3. Calculate metrics per variant\n  const variantMetrics = {};\n  \n  for (const variant of variants) {\n    const variantId = variant.id;\n    const variantRuns = runs.filter(r => r.variant_id === variantId);\n    \n    if (variantRuns.length === 0) {\n      variantMetrics[variantId] = {\n        variant_id: variantId,\n        variant_name: variant.name,\n        run_count: 0,\n        avg_confidence: 0.5,\n        avg_latency_ms: 0,\n        error_rate: 0,\n        exploration_score: 1.0 // Higher for variants with fewer runs\n      };\n      continue;\n    }\n    \n    const successfulRuns = variantRuns.filter(r => r.status === 'complete' && r.output);\n    const errorCount = variantRuns.filter(r => r.status === 'error').length;\n    \n    const confidences = successfulRuns.map(r => parseFloat(r.output?.confidence || 0.5));\n    const latencies = successfulRuns.map(r => parseInt(r.output?.latency_ms || 0));\n    \n    const avgConfidence = confidences.length > 0 ? confidences.reduce((a, b) => a + b, 0) / confidences.length : 0.5;\n    const avgLatency = latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0;\n    const errorRate = variantRuns.length > 0 ? errorCount / variantRuns.length : 0;\n    \n    // Exploration bonus: favor variants with fewer runs (epsilon-greedy)\n    const explorationScore = 1.0 / Math.max(1, variantRuns.length);\n    \n    variantMetrics[variantId] = {\n      variant_id: variantId,\n      variant_name: variant.name,\n      run_count: variantRuns.length,\n      avg_confidence: avgConfidence,\n      avg_latency_ms: avgLatency,\n      error_rate: errorRate,\n      exploration_score: explorationScore\n    };\n  }\n  \n  // 4. Multi-armed bandit selection\n  // UCB (Upper Confidence Bound) style: confidence * (1 - error_rate) * exploration_bonus\n  let bestVariantId = null;\n  let bestScore = -Infinity;\n  \n  for (const [variantId, metrics] of Object.entries(variantMetrics)) {\n    // Score = (confidence * (1 - error_rate) * 0.7) + (exploration_score * 0.3)\n    const exploitationScore = metrics.avg_confidence * (1 - metrics.error_rate) * 0.7;\n    const explorationBonus = metrics.exploration_score * 0.3;\n    const totalScore = exploitationScore + explorationBonus;\n    \n    if (totalScore > bestScore) {\n      bestScore = totalScore;\n      bestVariantId = variantId;\n    }\n  }\n  \n  if (!bestVariantId) {\n    // Fallback to first variant\n    bestVariantId = variants[0].id;\n  }\n  \n  const selectedVariant = variants.find(v => v.id === bestVariantId);\n  \n  // 5. Emit prompt_variant_selection span\n  const selectionId = crypto.randomUUID();\n  const selectionSpan = {\n    id: selectionId,\n    seq: 0,\n    entity_type: 'prompt_variant_selection',\n    who: 'edge:prompt_bandit',\n    did: 'selected',\n    this: prompt_family,\n    at: now(),\n    status: 'complete',\n    owner_id: selectedVariant.owner_id,\n    tenant_id: selectedVariant.tenant_id,\n    visibility: selectedVariant.visibility || 'private',\n    related_to: [bestVariantId],\n    input: {\n      prompt_family: prompt_family,\n      window_days: window_days,\n      variant_count: variants.length\n    },\n    output: {\n      current: {\n        id: bestVariantId,\n        name: selectedVariant.name,\n        score: bestScore\n      },\n      metrics: variantMetrics,\n      selection_reason: 'multi_armed_bandit'\n    },\n    metadata: {\n      prompt_family: prompt_family\n    }\n  };\n  \n  await insertSpan(selectionSpan);\n  \n  return {\n    ok: true,\n    selection_id: selectionId,\n    selected_variant: {\n      id: bestVariantId,\n      name: selectedVariant.name,\n      score: bestScore\n    },\n    metrics: variantMetrics,\n    window_days: window_days\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

