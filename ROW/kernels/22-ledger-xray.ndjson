{"id":"00000000-0000-4000-8000-000000000022","seq":0,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-11-05T00:00:00Z","status":"active","name":"ledger_xray","description":"Ledger X-Ray: schema, RLS, kernels, spans, signatures, integrity, activity, performance","code":"globalThis.default = async function ledgerXray(ctx){\n  const { sql, now } = ctx;\n  const input = ctx.input || {};\n  const sections = Array.isArray(input.sections) && input.sections.length ? input.sections : ['schema','rls','kernels','spans','signatures','integrity','activity','performance'];\n  const limit = Number.isInteger(input.limit) ? Math.max(1, Math.min(1000, input.limit)) : 20;\n  const since = input.since ? new Date(input.since) : new Date(Date.now() - 24*3600*1000);\n  const until = input.until ? new Date(input.until) : new Date();\n\n  const report = {};\n  const startedAt = Date.now();\n  const latencyBy = {};\n\n  async function timed(name, fn){\n    const t0 = Date.now();\n    try {\n      report[name] = await fn();\n    } catch (e){\n      report[name] = { status:'error', error: String(e.message || e) };\n    } finally { latencyBy[name] = Date.now() - t0; }\n  }\n\n  if (sections.includes('schema')){\n    await timed('schema', async ()=>{\n      const cols = await sql`\n        SELECT column_name, data_type, is_nullable\n        FROM information_schema.columns\n        WHERE table_schema = 'ledger' AND table_name = 'universal_registry'\n        ORDER BY ordinal_position`;\n      const idx = await sql`\n        SELECT indexname, indexdef\n        FROM pg_indexes\n        WHERE schemaname = 'ledger' AND tablename = 'universal_registry'\n        ORDER BY indexname`;\n      return { columns: cols, indexes: idx.map(i=>i.indexname) };\n    });\n  }\n\n  if (sections.includes('rls')){\n    await timed('rls', async ()=>{\n      const rls = await sql`\n        SELECT tablename, rowsecurity\n        FROM pg_tables\n        WHERE schemaname = 'ledger' AND tablename = 'universal_registry'`;\n      const policies = await sql`\n        SELECT policyname, permissive, roles, cmd, qual\n        FROM pg_policies\n        WHERE schemaname = 'ledger' AND tablename = 'universal_registry'`;\n      return { enabled: rls[0]?.rowsecurity === true || rls[0]?.rowsecurity === 't', policies };\n    });\n  }\n\n  if (sections.includes('kernels')){\n    await timed('kernels', async ()=>{\n      const ks = await sql`\n        SELECT id, name, seq, at, status\n        FROM ledger.visible_timeline\n        WHERE entity_type = 'function' AND status = 'active'\n        ORDER BY at ASC\n        LIMIT ${limit}`;\n      return ks;\n    });\n  }\n\n  if (sections.includes('spans')){\n    await timed('spans', async ()=>{\n      const byType = await sql`\n        SELECT entity_type, COUNT(*) AS total, COUNT(DISTINCT id) AS unique_ids\n        FROM ledger.visible_timeline\n        GROUP BY entity_type\n        ORDER BY total DESC\n        LIMIT ${limit}`;\n      const total = await sql`SELECT COUNT(*)::bigint AS total FROM ledger.visible_timeline`;\n      const byStatus = await sql`\n        SELECT status, COUNT(*) AS count\n        FROM ledger.visible_timeline\n        GROUP BY status\n        ORDER BY count DESC`;\n      const latest = await sql`\n        SELECT id, entity_type, who, did, at\n        FROM ledger.visible_timeline\n        WHERE at BETWEEN ${since} AND ${until}\n        ORDER BY at DESC\n        LIMIT ${limit}`;\n      return { by_type: byType, total: Number(total[0]?.total || 0n), by_status: byStatus, latest };\n    });\n  }\n\n  if (sections.includes('signatures')){\n    await timed('signatures', async ()=>{\n      const rows = await sql`\n        SELECT\n          COUNT(*) AS total,\n          COUNT(CASE WHEN signature IS NOT NULL THEN 1 END) AS signed,\n          COUNT(CASE WHEN payload_hash IS NOT NULL THEN 1 END) AS has_hash,\n          COUNT(CASE WHEN sig_key_id IS NOT NULL THEN 1 END) AS has_key_id\n        FROM ledger.visible_timeline\n        WHERE entity_type IN ('function','api_token_issued','wallet_opened','api_key_request')`;\n      const r = rows[0] || { total:0, signed:0, has_hash:0, has_key_id:0 };\n      const total = Number(r.total||0);\n      const pct = (n)=> total? Math.round((Number(n||0)/total)*1000)/10 : 0;\n      return { total, signed:Number(r.signed||0), has_hash:Number(r.has_hash||0), has_key_id:Number(r.has_key_id||0), pct_signed:pct(r.signed), pct_hashed:pct(r.has_hash) };\n    });\n  }\n\n  if (sections.includes('integrity')){\n    await timed('integrity', async ()=>{\n      const versions = await sql`\n        SELECT id, COUNT(*) AS count, MIN(seq) AS min_seq, MAX(seq) AS max_seq\n        FROM ledger.visible_timeline\n        GROUP BY id\n        HAVING COUNT(*) > 1\n        ORDER BY count DESC\n        LIMIT ${limit}`;\n      const orphans = await sql`\n        SELECT COUNT(*)::bigint AS count\n        FROM ledger.visible_timeline\n        WHERE owner_id IS NULL`;\n      const emptyMeta = await sql`\n        SELECT COUNT(*)::bigint AS count\n        FROM ledger.visible_timeline\n        WHERE metadata IS NULL OR metadata::text = '{}'`;\n      return { versioned: versions, orphans:Number(orphans[0]?.count||0n), metadata_empty:Number(emptyMeta[0]?.count||0n) };\n    });\n  }\n\n  if (sections.includes('activity')){\n    await timed('activity', async ()=>{\n      const last24 = await sql`\n        SELECT COUNT(*)::bigint AS count\n        FROM ledger.visible_timeline\n        WHERE at > (now() - interval '24 hours')`;\n      const lastWeek = await sql`\n        SELECT COUNT(*)::bigint AS count\n        FROM ledger.visible_timeline\n        WHERE at > (now() - interval '7 days')`;\n      const latest = await sql`\n        SELECT id, entity_type, who, did, at\n        FROM ledger.visible_timeline\n        ORDER BY at DESC\n        LIMIT ${limit}`;\n      return { last_24h: Number(last24[0]?.count||0n), last_week:Number(lastWeek[0]?.count||0n), latest };\n    });\n  }\n\n  if (sections.includes('performance')){\n    await timed('performance', async ()=>{\n      const size = await sql`\n        SELECT \n          pg_size_pretty(pg_total_relation_size('ledger.universal_registry')) AS total_size,\n          pg_size_pretty(pg_relation_size('ledger.universal_registry')) AS table_size,\n          pg_size_pretty(pg_indexes_size('ledger.universal_registry')) AS indexes_size`;\n      const approx = await sql`\n        SELECT reltuples::bigint AS estimate\n        FROM pg_class\n        WHERE relname = 'universal_registry'\n          AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'ledger')`;\n      return { total_size:size[0]?.total_size, table_size:size[0]?.table_size, indexes_size:size[0]?.indexes_size, estimate:Number(approx[0]?.estimate||0n) };\n    });\n  }\n\n  const durationMs = Date.now() - startedAt;\n  return { status:'complete', report, metrics:{ duration_ms: durationMs, latency_ms_by_section: latencyBy, limit, since: since.toISOString(), until: until.toISOString() } };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

