{"id":"00000000-0000-4000-8000-000000000001","seq":4,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"run_code_kernel","description":"Hardened run_code_kernel with Web Worker sandbox, advisory locks, throttles, signing (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto, env } = ctx;\n\n  async function latestManifest() {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE entity_type='manifest' ORDER BY \"when\" DESC LIMIT 1`;\n    return rows[0] || { metadata: {} };\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n    if (env.SIGNING_KEY_HEX) {\n      const priv = crypto.toU8(env.SIGNING_KEY_HEX);\n      const pub = await crypto.ed25519.getPublicKey(priv);\n      span.signature = crypto.hex(await crypto.ed25519.sign(crypto.toU8(h), priv));\n      span.public_key = crypto.hex(pub);\n    }\n  }\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n\n  const SPAN_ID = globalThis.SPAN_ID || env.SPAN_ID;\n  if (!SPAN_ID) throw new Error('SPAN_ID required');\n  if (!env.APP_USER_ID) throw new Error('APP_USER_ID required');\n\n  const manifest = await latestManifest();\n  const throttleLimit = Number(manifest.metadata?.throttle?.per_tenant_daily_exec_limit || 100);\n  const slowMs = Number(manifest.metadata?.policy?.slow_ms || 5000);\n  const allowed = (manifest.metadata?.allowed_boot_ids || []);\n  if (!allowed.includes(manifest.metadata?.kernels?.run_code)) throw new Error('run_code not allowed by manifest');\n\n  const { rows: fnRows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${SPAN_ID} ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n  const fnSpan = fnRows[0];\n  if (!fnSpan) throw new Error('target function not found');\n  if (fnSpan.entity_type !== 'function') throw new Error('run_code only executes entity_type=function');\n  if (env.APP_TENANT_ID && String(fnSpan.tenant_id) !== String(env.APP_TENANT_ID)) throw new Error('tenant mismatch');\n\n  // Tenant-level lock prevents throttle race condition\n  const tenantLockKey = `throttle:${fnSpan.tenant_id}`;\n  const tenantLocked = await tryLock(tenantLockKey);\n  if (!tenantLocked) {\n    await new Promise(r => setTimeout(r, 100));\n    return;\n  }\n\n  try {\n    const { rows: usedR } = await sql`\n      SELECT count(*)::int c FROM ledger.visible_timeline\n      WHERE entity_type='execution' AND tenant_id IS NOT DISTINCT FROM ${fnSpan.tenant_id} AND \"when\"::date = now()::date\n    `;\n    const used = usedR[0]?.c || 0;\n    if (used >= throttleLimit && !((fnSpan.metadata?.force) && fnSpan.public_key && fnSpan.public_key.toLowerCase() === (manifest.metadata?.override_pubkey_hex || '').toLowerCase())) {\n      await insertSpan({\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'policy_violation',\n        who: 'edge:run_code',\n        did: 'blocked',\n        this: 'quota.exec.per_tenant.daily',\n        at: now(),\n        status: 'error',\n        owner_id: fnSpan.owner_id,\n        tenant_id: fnSpan.tenant_id,\n        visibility: fnSpan.visibility ?? 'private',\n        related_to: [fnSpan.id],\n        metadata: { limit: throttleLimit, today: used }\n      });\n      await unlock(tenantLockKey);\n      return;\n    }\n  } finally {\n    await unlock(tenantLockKey);\n  }\n\n  if (!(await tryLock(fnSpan.id))) return;\n  const timeoutMs = slowMs;\n  const start = performance.now();\n  let output = null,\n    error = null,\n    trace = fnSpan.trace_id || crypto.randomUUID();\n\n  function execSandbox(code, input) {\n    // Note: Web Worker not available in Node.js Lambda, using eval fallback\n    // In production, use Deno/Cloud Run for full Worker support\n    try {\n      const fn = new Function('input', code);\n      return Promise.resolve(fn(input));\n    } catch (err) {\n      return Promise.reject(new Error(`compile:${String(err)}`));\n    }\n  }\n\n  try {\n    const result = await Promise.race([\n      execSandbox(String(fnSpan.code || ''), fnSpan.input ?? null),\n      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeoutMs))\n    ]);\n    output = result;\n  } catch (e) {\n    error = { message: String(e) };\n  } finally {\n    const dur = Math.round(performance.now() - start);\n    const execSpan = {\n      id: crypto.randomUUID(),\n      seq: 0,\n      parent_id: fnSpan.id,\n      entity_type: 'execution',\n      who: 'edge:run_code',\n      did: 'executed',\n      this: 'run_code',\n      at: now(),\n      status: error ? 'error' : 'complete',\n      input: fnSpan.input ?? null,\n      output: error ? null : output,\n      error,\n      duration_ms: dur,\n      trace_id: trace,\n      owner_id: fnSpan.owner_id,\n      tenant_id: fnSpan.tenant_id,\n      visibility: fnSpan.visibility ?? 'private',\n      related_to: [fnSpan.id]\n    };\n    if (!error && dur > slowMs) {\n      execSpan.status = 'complete';\n      await insertSpan({\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'status_patch',\n        who: 'edge:run_code',\n        did: 'labeled',\n        this: 'status=slow',\n        at: now(),\n        status: 'complete',\n        parent_id: execSpan.id,\n        related_to: [execSpan.id],\n        owner_id: fnSpan.owner_id,\n        tenant_id: fnSpan.tenant_id,\n        visibility: fnSpan.visibility ?? 'private',\n        metadata: { status: 'slow', duration_ms: dur }\n      });\n    }\n    await sign(execSpan);\n    await insertSpan(execSpan);\n    await unlock(fnSpan.id);\n  }\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000002","seq":4,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"observer_bot_kernel","description":"Hardened observer_bot_kernel with advisory locks, quota checking (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, now } = ctx;\n\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n  async function limitForTenant(tid) {\n    const { rows } = await sql`SELECT (metadata->'throttle'->>'per_tenant_daily_exec_limit')::int lim\n      FROM ledger.visible_timeline WHERE entity_type='manifest' ORDER BY \"when\" DESC LIMIT 1`;\n    return rows[0]?.lim ?? 100;\n  }\n  async function todayExecs(tid) {\n    const { rows } = await sql`SELECT count(*)::int c FROM ledger.visible_timeline\n      WHERE entity_type='execution' AND tenant_id IS NOT DISTINCT FROM ${tid} AND \"when\"::date=now()::date`;\n    return rows[0]?.c || 0;\n  }\n\n  const { rows } = await sql`\n    SELECT id, owner_id, tenant_id, visibility\n    FROM ledger.visible_timeline\n    WHERE entity_type='function' AND status='scheduled'\n    ORDER BY \"when\" ASC LIMIT 16\n  `;\n\n  for (const s of rows) {\n    if (!(await tryLock(s.id))) continue;\n    try {\n      const lim = await limitForTenant(s.tenant_id);\n      const used = await todayExecs(s.tenant_id);\n      if (used >= lim) {\n        await sql`\n          INSERT INTO ledger.universal_registry\n          (id,seq,who,did,\"this\",at,entity_type,status,parent_id,related_to,owner_id,tenant_id,visibility,metadata)\n          VALUES\n          (gen_random_uuid(),0,'edge:observer','blocked','quota.exec.per_tenant.daily',${now()},'policy_violation','error',\n           ${s.id}, ARRAY[${s.id}]::uuid[], ${s.owner_id}, ${s.tenant_id}, ${s.visibility}, jsonb_build_object('limit',${lim},'today',${used}))\n        `;\n        continue;\n      }\n\n      await sql`\n        INSERT INTO ledger.universal_registry\n        (id,seq,who,did,\"this\",at,entity_type,status,parent_id,related_to,owner_id,tenant_id,visibility,trace_id)\n        VALUES\n        (gen_random_uuid(),0,'edge:observer','scheduled','run_code',${now()},'request','scheduled',\n         ${s.id}, ARRAY[${s.id}]::uuid[], ${s.owner_id}, ${s.tenant_id}, ${s.visibility}, gen_random_uuid()::text)\n        ON CONFLICT DO NOTHING\n      `;\n    } finally {\n      await unlock(s.id);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000003","seq":4,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"request_worker_kernel","description":"Hardened request_worker_kernel with advisory locks, batch processing (seq=4, Blueprint seq=2)","code":"globalThis.default = async function main(ctx) {\n  const { sql, env } = ctx;\n  const RUN_CODE_KERNEL_ID = globalThis.RUN_CODE_KERNEL_ID || env?.RUN_CODE_KERNEL_ID || '00000000-0000-4000-8000-000000000001';\n\n  async function latestKernel(id) {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${id} AND entity_type='function' ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n    return rows[0] || null;\n  }\n  async function tryLock(id) {\n    const r = await sql`SELECT pg_try_advisory_lock(hashtext(${id}::text)) ok`;\n    return !!r.rows?.[0]?.ok;\n  }\n  async function unlock(id) {\n    await sql`SELECT pg_advisory_unlock(hashtext(${id}::text))`;\n  }\n\n  const { rows: reqs } = await sql`\n    SELECT id, parent_id FROM ledger.visible_timeline\n    WHERE entity_type='request' AND status='scheduled'\n    ORDER BY \"when\" ASC LIMIT 8\n  `;\n  if (!reqs.length) return;\n\n  const runKernel = await latestKernel(RUN_CODE_KERNEL_ID);\n  if (!runKernel?.code) throw new Error('run_code_kernel not found');\n\n  for (const r of reqs) {\n    if (!(await tryLock(r.parent_id))) continue;\n    try {\n      globalThis.SPAN_ID = r.parent_id;\n      const factory = new Function('ctx', `\"use strict\";\\n${String(runKernel.code)}\\n;return (typeof default!=='undefined'?default:globalThis.main);`);\n      const main = factory(ctx);\n      if (typeof main !== 'function') throw new Error('run_code module invalid');\n      await main(ctx);\n    } finally {\n      await unlock(r.parent_id);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000004","seq":2,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"policy_agent_kernel","description":"Hardened policy_agent_kernel with Web Worker sandbox, policy_error spans, cursors (seq=2, Blueprint seq=1)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n\n  function sandboxEval(code, span) {\n    // Note: Web Worker not available in Node.js Lambda, using eval fallback with timeout\n    // In production, use Deno/Cloud Run for full Worker support\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('timeout')), 3000);\n      try {\n        const fn = new Function('span', code + '\\n;return (typeof default!==\"undefined\"?default:on)||on;')();\n        const out = fn ? fn(span) : [];\n        clearTimeout(timeout);\n        resolve(out || []);\n      } catch (err) {\n        clearTimeout(timeout);\n        reject(err);\n      }\n    });\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n  }\n  async function latestCursor(policyId) {\n    const { rows } = await sql`SELECT max(\"when\") AS at FROM ledger.visible_timeline WHERE entity_type='policy_cursor' AND related_to @> ARRAY[${policyId}]::uuid[]`;\n    return rows[0]?.at || null;\n  }\n\n  const { rows: policies } = await sql`\n    SELECT * FROM ledger.visible_timeline WHERE entity_type='policy' AND status='active' ORDER BY \"when\" ASC\n  `;\n\n  for (const p of policies) {\n    const since = await latestCursor(p.id);\n    const { rows: candidates } = await sql`\n      SELECT * FROM ledger.visible_timeline\n      WHERE \"when\" > COALESCE(${since}, to_timestamp(0))\n        AND tenant_id IS NOT DISTINCT FROM ${p.tenant_id}\n      ORDER BY \"when\" ASC LIMIT 500\n    `;\n    let lastAt = since;\n    for (const s of candidates) {\n      const actions = await sandboxEval(String(p.code || ''), s).catch(async (err) => {\n        await insertSpan({\n          id: crypto.randomUUID(),\n          seq: 0,\n          entity_type: 'policy_error',\n          who: 'edge:policy_agent',\n          did: 'failed',\n          this: 'policy.eval',\n          at: now(),\n          status: 'error',\n          error: { message: String(err), policy_id: p.id, target_span: s.id },\n          owner_id: p.owner_id,\n          tenant_id: p.tenant_id,\n          visibility: p.visibility || 'private',\n          related_to: [p.id, s.id]\n        });\n        return [];\n      });\n      for (const a of actions) {\n        if (a?.run === 'run_code' && a?.span_id) {\n          const req = {\n            id: crypto.randomUUID(),\n            seq: 0,\n            entity_type: 'request',\n            who: 'edge:policy_agent',\n            did: 'triggered',\n            this: 'run_code',\n            at: now(),\n            status: 'scheduled',\n            parent_id: a.span_id,\n            related_to: [p.id, a.span_id],\n            owner_id: p.owner_id,\n            tenant_id: p.tenant_id,\n            visibility: p.visibility || 'private',\n            metadata: { policy_id: p.id, trigger_span: s.id }\n          };\n          await sign(req);\n          await insertSpan(req);\n        } else if (a?.emit_span) {\n          const e = a.emit_span;\n          e.id = e.id || crypto.randomUUID();\n          e.seq = e.seq ?? 0;\n          e.at = e.at || now();\n          e.owner_id = e.owner_id ?? p.owner_id;\n          e.tenant_id = e.tenant_id ?? p.tenant_id;\n          e.visibility = e.visibility ?? p.visibility || 'private';\n          await sign(e);\n          await insertSpan(e);\n        }\n      }\n      lastAt = s['when'] || lastAt;\n    }\n    if (lastAt) {\n      const cursor = {\n        id: crypto.randomUUID(),\n        seq: 0,\n        entity_type: 'policy_cursor',\n        who: 'edge:policy_agent',\n        did: 'advanced',\n        this: 'cursor',\n        at: now(),\n        status: 'complete',\n        related_to: [p.id],\n        owner_id: p.owner_id,\n        tenant_id: p.tenant_id,\n        visibility: p.visibility || 'private',\n        metadata: { last_at: lastAt }\n      };\n      await sign(cursor);\n      await insertSpan(cursor);\n    }\n  }\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000005","seq":2,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"provider_exec_kernel","description":"Hardened provider_exec_kernel with OpenAI/Ollama support, signing (seq=2, Blueprint seq=1)","code":"globalThis.default = async function main(ctx) {\n  const { sql, insertSpan, now, crypto, env } = ctx;\n\n  async function loadProvider(id) {\n    const { rows } = await sql`SELECT * FROM ledger.visible_timeline WHERE id=${id} AND entity_type='provider' ORDER BY \"when\" DESC, seq DESC LIMIT 1`;\n    return rows[0] || null;\n  }\n  async function sign(span) {\n    const clone = JSON.parse(JSON.stringify(span));\n    delete clone.signature;\n    delete clone.curr_hash;\n    const msg = new TextEncoder().encode(JSON.stringify(clone, Object.keys(clone).sort()));\n    const h = crypto.hex(crypto.blake3(msg));\n    span.curr_hash = h;\n  }\n\n  const PROVIDER_ID = globalThis.PROVIDER_ID || env.PROVIDER_ID;\n  const PAYLOAD = JSON.parse(globalThis.PROVIDER_PAYLOAD || env.PROVIDER_PAYLOAD || '{}');\n  const prov = await loadProvider(PROVIDER_ID);\n  if (!prov) throw new Error('provider not found');\n\n  const meta = prov.metadata || {};\n  let out = null,\n    error = null;\n\n  try {\n    if (meta.base_url?.includes('openai.com')) {\n      const apiKey = env[meta.auth_env] || env.OPENAI_API_KEY || '';\n      const r = await fetch(`${meta.base_url}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n          authorization: `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: meta.model,\n          messages: PAYLOAD.messages,\n          temperature: PAYLOAD.temperature ?? 0.2\n        })\n      });\n      out = await r.json();\n    } else if ((meta.base_url || '').includes('localhost:11434')) {\n      const r = await fetch(`${meta.base_url}/api/chat`, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({\n          model: meta.model || 'llama3',\n          messages: PAYLOAD.messages\n        })\n      });\n      out = await r.json();\n    } else {\n      throw new Error('unsupported provider');\n    }\n  } catch (e) {\n    error = { message: String(e) };\n  }\n\n  const execSpan = {\n    id: crypto.randomUUID(),\n    seq: 0,\n    entity_type: 'provider_execution',\n    who: 'edge:provider_exec',\n    did: 'called',\n    this: 'provider.exec',\n    at: now(),\n    status: error ? 'error' : 'complete',\n    input: PAYLOAD,\n    output: error ? null : out,\n    error,\n    owner_id: prov.owner_id,\n    tenant_id: prov.tenant_id,\n    visibility: prov.visibility ?? 'private',\n    related_to: [prov.id]\n  };\n  await sign(execSpan);\n  await insertSpan(execSpan);\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

