{"id":"00000000-0000-4000-8000-000000000010","seq":1,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"memory_search_kernel","description":"Searches memories with scope ranking (session→private→tenant→public), text/vector search, context budget","code":"globalThis.default = async function searchMemory(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { Q, TOPK = 10, USE_VECTOR = false, session_id, memory_mode = 'on' } = ctx.input || {};\n  \n  if (!Q) {\n    throw new Error('Missing required field: Q (query string)');\n  }\n  \n  const userId = ctx.env.APP_USER_ID || 'system';\n  const tenantId = ctx.env.APP_TENANT_ID || 'system';\n  \n  // 1. Respect memory_mode: off|session-only|on\n  if (memory_mode === 'off') {\n    return {\n      ok: true,\n      hits: [],\n      count: 0,\n      mode: 'off'\n    };\n  }\n  \n  // 2. Scope ranking: session → private → tenant → public\n  const searchPattern = '%' + String(Q).replace(/'/g, \"''\") + '%';\n  \n  // Build queries for each scope (in priority order)\n  const hits = [];\n  const seenIds = new Set();\n  \n  // Session scope (exact session_id match)\n  if (session_id && (memory_mode === 'session-only' || memory_mode === 'on')) {\n    const sessionResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND metadata->>$3 = $4 AND (metadata->>$5 ILIKE $6 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$7) tag WHERE tag ILIKE $6)) ORDER BY at DESC LIMIT $8',\n      ['memory', 'active', 'session_id', session_id, 'content', searchPattern, 'tags', TOPK]\n    );\n    \n    for (const row of sessionResult.rows) {\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 1.0,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'session',\n          scope: 'session',\n          stored_at: row.at\n        });\n      }\n    }\n    \n    if (memory_mode === 'session-only') {\n      return formatResults(hits, Q, TOPK);\n    }\n  }\n  \n  // Private scope (user's own memories)\n  if (hits.length < TOPK) {\n    const privateResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND owner_id = $3 AND visibility = $4 AND (metadata->>$5 IN ($6, $7)) AND (metadata->>$8 ILIKE $9 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$10) tag WHERE tag ILIKE $9)) ORDER BY at DESC LIMIT $11',\n      ['memory', 'active', userId, 'private', 'layer', 'temporary', 'permanent', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of privateResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.8,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'local',\n          scope: 'private',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // Tenant scope\n  if (hits.length < TOPK) {\n    const tenantResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND tenant_id = $3 AND visibility IN ($4, $5) AND (metadata->>$6 ILIKE $7 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$8) tag WHERE tag ILIKE $7)) ORDER BY at DESC LIMIT $9',\n      ['memory', 'active', tenantId, 'tenant', 'public', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of tenantResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.6,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'shared',\n          scope: 'tenant',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // Public scope (if still room)\n  if (hits.length < TOPK) {\n    const publicResult = await sql(\n      'SELECT id, at, metadata, content, visibility FROM ledger.visible_timeline WHERE entity_type = $1 AND status = $2 AND visibility = $3 AND (metadata->>$4 ILIKE $5 OR EXISTS (SELECT 1 FROM jsonb_array_elements_text(metadata->$6) tag WHERE tag ILIKE $5)) ORDER BY at DESC LIMIT $7',\n      ['memory', 'active', 'public', 'content', searchPattern, 'tags', TOPK - hits.length]\n    );\n    \n    for (const row of publicResult.rows) {\n      if (hits.length >= TOPK) break;\n      if (!seenIds.has(row.id)) {\n        seenIds.add(row.id);\n        hits.push({\n          span_id: row.id,\n          score: 0.4,\n          preview: extractPreview(row),\n          layer: row.metadata?.layer || 'shared',\n          scope: 'public',\n          stored_at: row.at\n        });\n      }\n    }\n  }\n  \n  // 3. Optional vector search (if USE_VECTOR=true and pgvector available)\n  // TODO: Implement vector similarity search when pgvector is available\n  \n  // 4. Emit memory_search_result span\n  const searchId = crypto.randomUUID();\n  const searchSpan = {\n    id: searchId,\n    seq: 0,\n    entity_type: 'memory_search_result',\n    who: 'kernel:memory_search',\n    did: 'searched',\n    this: 'memory.search',\n    at: now(),\n    status: 'complete',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    input: {\n      query: Q,\n      topk: TOPK,\n      use_vector: USE_VECTOR,\n      session_id: session_id || null,\n      memory_mode: memory_mode\n    },\n    output: {\n      hits: hits,\n      count: hits.length\n    },\n    metadata: {\n      query: Q,\n      hit_count: hits.length\n    }\n  };\n  \n  await insertSpan(searchSpan);\n  \n  return formatResults(hits, Q, TOPK);\n  \n  // Helper functions\n  function extractPreview(row) {\n    const content = row.content || row.metadata?.content || '';\n    if (typeof content === 'string') {\n      return content.substring(0, 160) + (content.length > 160 ? '...' : '');\n    }\n    if (content && content.redacted) {\n      return '[encrypted]';\n    }\n    return JSON.stringify(content || '').substring(0, 160);\n  }\n  \n  function formatResults(hits, query, topk) {\n    return {\n      ok: true,\n      query: query,\n      hits: hits,\n      count: hits.length,\n      topk: topk\n    };\n  }\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
