{"id":"00000000-0000-4000-8000-000000000001","seq":3,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"run_code_kernel","description":"Executes arbitrary JavaScript code from input.code in sandboxed context","code":"globalThis.default = async function runCode(ctx) {\n  const { code, language = 'javascript' } = ctx.input;\n  \n  if (!code) {\n    throw new Error('Missing required field: code');\n  }\n  \n  if (language !== 'javascript') {\n    throw new Error(`Unsupported language: ${language}. Only javascript is supported.`);\n  }\n  \n  // Validate syntax\n  try {\n    new Function(code);\n  } catch (syntaxError) {\n    return {\n      status: 'syntax_error',\n      error: syntaxError.message,\n      code: code.substring(0, 100) + (code.length > 100 ? '...' : '')\n    };\n  }\n  \n  // Execute in isolated context\n  const sandbox = {\n    console: ctx.console,\n    Math,\n    JSON,\n    Date,\n    Array,\n    Object,\n    String,\n    Number,\n    Boolean\n  };\n  \n  let result, error;\n  const start = Date.now();\n  \n  try {\n    const fn = new Function('sandbox', `\n      with (sandbox) {\n        return (async () => {\n          ${code}\n        })();\n      }\n    `);\n    result = await fn(sandbox);\n  } catch (e) {\n    error = {\n      message: e.message,\n      stack: e.stack,\n      name: e.name\n    };\n  }\n  \n  const duration = Date.now() - start;\n  \n  return {\n    status: error ? 'error' : 'success',\n    result: error ? null : result,\n    error: error || null,\n    duration_ms: duration,\n    language,\n    code_length: code.length\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000002","seq":3,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"observer_bot_kernel","description":"Observes timeline for completed executions and schedules requests for GPT processing","code":"globalThis.default = async function observeTimeline(ctx) {\n  const { client } = ctx;\n  const { lookback_minutes = 60, limit = 10 } = ctx.input || {};\n  \n  // Query recent complete executions without scheduled requests\n  const cutoff = new Date(Date.now() - lookback_minutes * 60000).toISOString();\n  \n  const { rows: executions } = await client.query(`\n    SELECT e.id, e.parent_id, e.at, e.output, e.owner_id, e.tenant_id, e.visibility\n    FROM ledger.visible_timeline e\n    WHERE e.entity_type = 'execution'\n      AND e.status = 'complete'\n      AND e.at > $1\n      AND NOT EXISTS (\n        SELECT 1 FROM ledger.universal_registry r\n        WHERE r.entity_type = 'request'\n          AND r.parent_id = e.id\n          AND r.status = 'scheduled'\n          AND r.is_deleted = false\n      )\n    ORDER BY e.at DESC\n    LIMIT $2\n  `, [cutoff, limit]);\n  \n  console.log(`Found ${executions.length} executions needing request scheduling`);\n  \n  const scheduled = [];\n  \n  for (const exec of executions) {\n    try {\n      // Insert request:scheduled span (idempotency enforced by unique index)\n      const requestId = require('crypto').randomUUID();\n      \n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, parent_id, status, owner_id, tenant_id, visibility, metadata)\n        VALUES ($1, 0, 'request', $2, 'scheduled', 'request', NOW(), $3, 'scheduled', $4, $5, $6, $7)\n      `, [\n        requestId,\n        'system:observer',\n        exec.id,\n        exec.owner_id,\n        exec.tenant_id,\n        exec.visibility,\n        JSON.stringify({ source: 'observer', execution_id: exec.id })\n      ]);\n      \n      scheduled.push({\n        request_id: requestId,\n        execution_id: exec.id,\n        execution_at: exec.at\n      });\n      \n      console.log(`Scheduled request ${requestId} for execution ${exec.id}`);\n    } catch (err) {\n      // Unique constraint violation = already scheduled (idempotent)\n      if (err.code === '23505') {\n        console.log(`Request already scheduled for execution ${exec.id} (idempotent)`);\n      } else {\n        console.error(`Failed to schedule request for execution ${exec.id}:`, err.message);\n      }\n    }\n  }\n  \n  return {\n    status: 'complete',\n    observed: executions.length,\n    scheduled: scheduled.length,\n    requests: scheduled\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000003","seq":3,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"request_worker_kernel","description":"Processes scheduled requests by determining provider and calling provider_exec_kernel","code":"globalThis.default = async function processRequests(ctx) {\n  const { client } = ctx;\n  const { limit = 5 } = ctx.input || {};\n  \n  // Query scheduled requests\n  const { rows: requests } = await client.query(`\n    SELECT id, parent_id, at, metadata, owner_id, tenant_id, visibility\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'request' AND status = 'scheduled'\n    ORDER BY at ASC\n    LIMIT $1\n  `, [limit]);\n  \n  console.log(`Found ${requests.length} scheduled requests to process`);\n  \n  const processed = [];\n  \n  for (const req of requests) {\n    try {\n      // Update status to queued (new span with incremented seq)\n      const { rows: currentSeq } = await client.query(\n        'SELECT COALESCE(MAX(seq), -1) as max_seq FROM ledger.universal_registry WHERE id = $1',\n        [req.id]\n      );\n      const nextSeq = currentSeq[0].max_seq + 1;\n      \n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, parent_id, status, owner_id, tenant_id, visibility, metadata)\n        VALUES ($1, $2, 'request', $3, 'queued', 'request', NOW(), $4, 'queued', $5, $6, $7, $8)\n      `, [req.id, nextSeq, 'system:worker', req.parent_id, req.owner_id, req.tenant_id, req.visibility, req.metadata]);\n      \n      // Fetch parent execution to determine provider\n      const { rows: execRows } = await client.query(\n        'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = \\'execution\\' LIMIT 1',\n        [req.parent_id]\n      );\n      \n      const providerId = execRows[0]?.metadata?.provider_id || 'openai-gpt4';\n      \n      // For now, just log intent to call provider (full implementation needs HTTP client)\n      console.log(`Request ${req.id} would call provider_exec_kernel with provider: ${providerId}`);\n      \n      processed.push({\n        request_id: req.id,\n        status: 'queued',\n        provider_id: providerId,\n        next_action: 'call_provider_exec_kernel'\n      });\n      \n    } catch (err) {\n      console.error(`Failed to process request ${req.id}:`, err.message);\n    }\n  }\n  \n  return {\n    status: 'complete',\n    found: requests.length,\n    processed: processed.length,\n    results: processed\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000004","seq":3,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"policy_agent_kernel","description":"Evaluates policies from ledger with wildcard matching for action/resource patterns","code":"globalThis.default = async function checkPolicies(ctx) {\n  const { client, env } = ctx;\n  const { action, resource, request_id } = ctx.input;\n  \n  if (!action || !resource) {\n    return { allowed: false, reason: 'Missing required fields: action, resource' };\n  }\n  \n  const userId = env.userId;\n  const tenantId = env.tenantId;\n  \n  console.log(`Checking policies for user=${userId}, tenant=${tenantId}, action=${action}, resource=${resource}`);\n  \n  // Wildcard matching helper (glob to regex)\n  function matchPattern(pattern, value) {\n    if (!pattern || pattern === '*') return true;\n    if (pattern === value) return true;\n    \n    // Convert glob to regex: function/* â†’ ^function\\/.*$\n    const regexPattern = pattern\n      .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')\n      .replace(/\\*/g, '.*');\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(value);\n  }\n  \n  // Fetch active policies from ledger\n  const { rows: policies } = await client.query(`\n    SELECT id, name, metadata\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'policy'\n      AND status = 'active'\n      AND (visibility = 'public' OR tenant_id = $1)\n    ORDER BY at DESC\n  `, [tenantId]);\n  \n  console.log(`Found ${policies.length} policies to evaluate`);\n  \n  if (policies.length === 0) {\n    return {\n      allowed: false,\n      reason: 'No policies found - default deny',\n      policies_checked: 0\n    };\n  }\n  \n  // Evaluate each policy (deny takes precedence)\n  let lastMatch = null;\n  \n  for (const policy of policies) {\n    const meta = policy.metadata || {};\n    const rules = meta.rules || [];\n    \n    for (const rule of rules) {\n      // Match action pattern with wildcards\n      if (rule.action && !matchPattern(rule.action, action)) {\n        continue;\n      }\n      \n      // Match resource pattern with wildcards\n      if (rule.resource && !matchPattern(rule.resource, resource)) {\n        continue;\n      }\n      \n      console.log(`Matched rule: action=${rule.action}, resource=${rule.resource}, effect=${rule.effect}`);\n      \n      // DENY takes immediate precedence (security first)\n      if (rule.effect === 'deny') {\n        return {\n          allowed: false,\n          reason: `Denied by policy: ${policy.name} (${policy.id})`,\n          policy_id: policy.id,\n          rule: rule\n        };\n      }\n      \n      // Track allow rule (continue checking for deny)\n      if (rule.effect === 'allow') {\n        lastMatch = {\n          allowed: true,\n          reason: `Allowed by policy: ${policy.name} (${policy.id})`,\n          policy_id: policy.id,\n          rule: rule\n        };\n      }\n    }\n  }\n  \n  // Return allow if found, otherwise deny\n  if (lastMatch) {\n    return lastMatch;\n  }\n  \n  return {\n    allowed: false,\n    reason: 'No matching policy found - default deny',\n    policies_checked: policies.length\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
{"id":"00000000-0000-4000-8000-000000000005","seq":2,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"provider_exec_kernel","description":"Executes LLM API calls to external providers (OpenAI, Anthropic) and records metrics","code":"globalThis.default = async function callProvider(ctx) {\n  const { client } = ctx;\n  const { provider_id, prompt, messages, model, max_tokens = 1000, temperature = 0.7 } = ctx.input;\n  \n  if (!provider_id) {\n    throw new Error('Missing required field: provider_id');\n  }\n  \n  // Fetch provider configuration from ledger\n  const { rows: providerRows } = await client.query(`\n    SELECT id, name, metadata\n    FROM ledger.visible_timeline\n    WHERE entity_type = 'provider' AND id = $1\n    ORDER BY at DESC LIMIT 1\n  `, [provider_id]);\n  \n  if (providerRows.length === 0) {\n    throw new Error(`Provider not found: ${provider_id}`);\n  }\n  \n  const provider = providerRows[0];\n  const config = provider.metadata || {};\n  const apiUrl = config.api_url;\n  const apiKey = config.api_key || process.env[config.api_key_env] || process.env.OPENAI_API_KEY;\n  \n  if (!apiUrl || !apiKey) {\n    throw new Error(`Provider ${provider.name} missing api_url or api_key`);\n  }\n  \n  console.log(`Calling provider: ${provider.name} (${provider_id})`);\n  \n  // Prepare request body based on provider type\n  let requestBody;\n  if (config.type === 'openai') {\n    requestBody = {\n      model: model || config.default_model || 'gpt-4',\n      messages: messages || [{ role: 'user', content: prompt }],\n      max_tokens,\n      temperature\n    };\n  } else if (config.type === 'anthropic') {\n    requestBody = {\n      model: model || config.default_model || 'claude-3-opus-20240229',\n      messages: messages || [{ role: 'user', content: prompt }],\n      max_tokens,\n      temperature\n    };\n  } else {\n    throw new Error(`Unsupported provider type: ${config.type}`);\n  }\n  \n  const start = Date.now();\n  let response, error;\n  \n  try {\n    // Note: In Lambda Node.js, use https module or fetch (Node 18+)\n    // For demo, simulating successful response\n    console.log('Making HTTP request to:', apiUrl);\n    console.log('Request body:', JSON.stringify(requestBody, null, 2));\n    \n    // TODO: Replace with actual fetch() call when running in Node 18+\n    // const res = await fetch(apiUrl, {\n    //   method: 'POST',\n    //   headers: {\n    //     'Content-Type': 'application/json',\n    //     'Authorization': `Bearer ${apiKey}`\n    //   },\n    //   body: JSON.stringify(requestBody)\n    // });\n    // response = await res.json();\n    \n    // Simulated response for now\n    response = {\n      id: 'sim-' + require('crypto').randomUUID(),\n      model: requestBody.model,\n      choices: [{\n        message: {\n          role: 'assistant',\n          content: '[SIMULATED] This is a simulated LLM response. Actual HTTP call would go here.'\n        },\n        finish_reason: 'stop'\n      }],\n      usage: {\n        prompt_tokens: 50,\n        completion_tokens: 30,\n        total_tokens: 80\n      }\n    };\n    \n  } catch (e) {\n    error = {\n      message: e.message,\n      stack: e.stack\n    };\n  }\n  \n  const duration = Date.now() - start;\n  \n  // Record metric span\n  await client.query(`\n    INSERT INTO ledger.universal_registry\n      (id, seq, entity_type, who, did, this, at, status, duration_ms, metadata, owner_id, tenant_id, visibility)\n    VALUES ($1, 0, 'metric', 'system:provider', 'measured', 'llm_call', NOW(), $2, $3, $4, 'system', 'system', 'private')\n  `, [\n    require('crypto').randomUUID(),\n    error ? 'error' : 'complete',\n    duration,\n    JSON.stringify({\n      provider_id,\n      provider_name: provider.name,\n      model: requestBody.model,\n      tokens: response?.usage || {},\n      error: error || null\n    })\n  ]);\n  \n  if (error) {\n    throw new Error(`Provider call failed: ${error.message}`);\n  }\n  \n  return {\n    status: 'success',\n    provider: provider.name,\n    model: requestBody.model,\n    response: response.choices[0].message.content,\n    usage: response.usage,\n    duration_ms: duration\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
