{"id":"c0c0c0c0-0000-4000-8000-runp00000001","seq":1,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"prompt_runner_kernel","description":"Runs prompt with variant, calls provider, records telemetry, emits prompt_run span","code":"globalThis.default = async function runPrompt(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { variant_id, compiled_hash, user_input, context, provider_id, model } = ctx.input || {};\n  \n  if (!user_input) {\n    throw new Error('Missing required field: user_input');\n  }\n  \n  const traceId = crypto.randomUUID();\n  const startTime = Date.now();\n  let systemPrompt = null;\n  let actualCompiledHash = compiled_hash;\n  \n  // 1. Get system prompt (from build or fetch latest build)\n  if (variant_id && !compiled_hash) {\n    // Fetch latest prompt_build for this variant\n    const buildResult = await sql(\n      'SELECT output FROM ledger.visible_timeline WHERE entity_type = $1 AND related_to @> ARRAY[$2]::uuid[] ORDER BY \"when\" DESC LIMIT 1',\n      ['prompt_build', variant_id]\n    );\n    \n    if (buildResult.rows.length > 0) {\n      const build = buildResult.rows[0];\n      systemPrompt = build.output?.system_prompt;\n      actualCompiledHash = build.output?.compiled_hash;\n    }\n  }\n  \n  // If no build found, call build_prompt_kernel\n  if (!systemPrompt && variant_id) {\n    // For now, we'll fetch blocks directly (in production, call build kernel)\n    const variantResult = await sql(\n      'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [variant_id, 'prompt_variant']\n    );\n    \n    if (variantResult.rows.length > 0) {\n      const blockIds = variantResult.rows[0].metadata?.block_ids || [];\n      if (blockIds.length > 0) {\n        const blockResult = await sql(\n          'SELECT content, metadata FROM ledger.visible_timeline WHERE entity_type = $1 AND id = ANY($2) AND status = $3 ORDER BY (metadata->>\\'priority\\')::int DESC NULLS LAST',\n          ['prompt_block', blockIds, 'active']\n        );\n        \n        const blocks = blockResult.rows.map(r => r.content || '').filter(Boolean);\n        systemPrompt = blocks.join('\\n\\n');\n        \n        // Compute hash\n        const promptBytes = new TextEncoder().encode(systemPrompt);\n        const hashBytes = crypto.blake3(promptBytes);\n        actualCompiledHash = crypto.hex(hashBytes);\n      }\n    }\n  }\n  \n  if (!systemPrompt) {\n    throw new Error('Could not build system prompt - missing variant_id or compiled_hash');\n  }\n  \n  // 2. Assemble messages array\n  const messages = [\n    { role: 'system', content: systemPrompt }\n  ];\n  \n  if (context) {\n    messages.push({ role: 'system', content: `CONTEXT:\\n${String(context)}` });\n  }\n  \n  messages.push({ role: 'user', content: String(user_input) });\n  \n  // 3. Call provider_exec_kernel\n  const defaultProviderId = provider_id || '00000000-0000-4000-8000-000000000005';\n  \n  // Fetch provider_exec_kernel\n  const providerKernelResult = await sql(\n    'SELECT code FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n    ['00000000-0000-4000-8000-000000000005', 'function']\n  );\n  \n  let providerResponse = null;\n  let providerError = null;\n  let providerModel = model || 'gpt-4';\n  let toolUseCount = 0;\n  \n  if (providerKernelResult.rows.length > 0) {\n    try {\n      // Execute provider kernel with messages\n      const providerCtx = {\n        ...ctx,\n        input: {\n          provider_id: defaultProviderId,\n          messages: messages,\n          model: providerModel,\n          temperature: 0.2\n        }\n      };\n      \n      const providerCode = providerKernelResult.rows[0].code;\n      const providerFn = new Function('ctx', `${providerCode}\\nreturn (typeof globalThis.default !== 'undefined' ? globalThis.default : main);`)(providerCtx);\n      \n      if (typeof providerFn === 'function') {\n        providerResponse = await providerFn(providerCtx);\n        providerModel = providerResponse.model || providerModel;\n      }\n    } catch (e) {\n      providerError = { message: e.message, stack: e.stack };\n    }\n  }\n  \n  const latencyMs = Date.now() - startTime;\n  \n  // 4. Parse response and ensure schema compliance\n  let responseText = providerResponse?.response || providerResponse?.choices?.[0]?.message?.content || '';\n  let confidence = 0.8; // Default confidence\n  \n  // Try to parse as JSON schema\n  try {\n    const parsed = typeof responseText === 'string' ? JSON.parse(responseText) : responseText;\n    if (parsed.text) {\n      responseText = parsed.text;\n      confidence = parsed.confidence || 0.8;\n    }\n  } catch (e) {\n    // Not JSON, use as-is\n  }\n  \n  // 5. Emit prompt_run span with telemetry\n  const runId = crypto.randomUUID();\n  const runSpan = {\n    id: runId,\n    seq: 0,\n    entity_type: 'prompt_run',\n    who: 'edge:prompt_runner',\n    did: 'ran',\n    this: 'prompt.run',\n    at: now(),\n    status: providerError ? 'error' : 'complete',\n    owner_id: ctx.env.APP_USER_ID || 'system',\n    tenant_id: ctx.env.APP_TENANT_ID || 'system',\n    visibility: 'private',\n    related_to: variant_id ? [variant_id] : [],\n    input: {\n      variant_id: variant_id || null,\n      compiled_hash: actualCompiledHash,\n      user_input: user_input,\n      context: context || null,\n      provider_id: defaultProviderId\n    },\n    output: {\n      text: responseText,\n      confidence: confidence,\n      model: providerModel,\n      latency_ms: latencyMs,\n      tool_use_count: toolUseCount\n    },\n    error: providerError || null,\n    duration_ms: latencyMs,\n    trace_id: traceId,\n    metadata: {\n      compiled_hash: actualCompiledHash,\n      provider_model: providerModel\n    }\n  };\n  \n  await insertSpan(runSpan);\n  \n  // 6. Return schema-compliant response\n  return {\n    text: responseText,\n    confidence: confidence,\n    follow_up_question: null,\n    actions: [],\n    citations: [],\n    telemetry: {\n      tool_use_count: toolUseCount,\n      latency_ms: latencyMs,\n      model: providerModel,\n      compiled_hash: actualCompiledHash,\n      trace_id: traceId\n    }\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

