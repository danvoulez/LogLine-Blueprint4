{"id":"c0c0c0c0-0000-4000-8000-eval00000001","seq":1,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"prompt_eval_kernel","description":"Evaluates prompt variants using fixtures (happy+stress), validates constraints, emits eval results","code":"globalThis.default = async function evalPrompt(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { eval_id, variant_id } = ctx.input || {};\n  \n  if (!eval_id && !variant_id) {\n    throw new Error('Missing required field: eval_id or variant_id');\n  }\n  \n  // 1. Load prompt_eval span by ID (or create from variant_id)\n  let evalSpan = null;\n  \n  if (eval_id) {\n    const evalResult = await sql(\n      'SELECT * FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [eval_id, 'prompt_eval']\n    );\n    evalSpan = evalResult.rows[0];\n  }\n  \n  if (!evalSpan && variant_id) {\n    // Try to find eval by prompt_id in metadata\n    const evalResult = await sql(\n      'SELECT * FROM ledger.visible_timeline WHERE entity_type = $1 AND metadata->>\\'prompt_id\\' = (SELECT name FROM ledger.visible_timeline WHERE id = $2 LIMIT 1) ORDER BY \"when\" DESC LIMIT 1',\n      ['prompt_eval', variant_id]\n    );\n    evalSpan = evalResult.rows[0];\n  }\n  \n  if (!evalSpan) {\n    throw new Error('Prompt eval not found');\n  }\n  \n  const evalInput = evalSpan.input || {};\n  const fixtures = evalInput.fixtures || [];\n  const targetVariantId = variant_id || evalSpan.related_to?.[0];\n  \n  if (!targetVariantId) {\n    throw new Error('Could not determine target variant_id');\n  }\n  \n  // 2. Fetch prompt_runner_kernel\n  const runnerResult = await sql(\n    'SELECT code FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n    ['c0c0c0c0-0000-4000-8000-runp00000001', 'function']\n  );\n  \n  if (runnerResult.rows.length === 0) {\n    throw new Error('prompt_runner_kernel not found');\n  }\n  \n  const runnerCode = runnerResult.rows[0].code;\n  const runnerFn = new Function('ctx', `${runnerCode}\\nreturn (typeof globalThis.default !== 'undefined' ? globalThis.default : main);`)(ctx);\n  \n  if (typeof runnerFn !== 'function') {\n    throw new Error('prompt_runner_kernel is not a function');\n  }\n  \n  // 3. Run each fixture through prompt_runner_kernel\n  const results = [];\n  const passFail = { happy: { pass: 0, fail: 0 }, ambiguous: { pass: 0, fail: 0 }, overlong_context: { pass: 0, fail: 0 }, conflicting: { pass: 0, fail: 0 }, tool_unavailable: { pass: 0, fail: 0 } };\n  \n  for (const fixture of fixtures) {\n    const fixtureType = fixture.type || 'happy';\n    let fixtureResult = null;\n    let fixtureError = null;\n    \n    try {\n      // Run fixture through runner\n      const runnerCtx = {\n        ...ctx,\n        input: {\n          variant_id: targetVariantId,\n          user_input: fixture.input,\n          context: fixture.context || null,\n          provider_id: fixture.provider_id || null\n        }\n      };\n      \n      fixtureResult = await runnerFn(runnerCtx);\n    } catch (e) {\n      fixtureError = { message: e.message, stack: e.stack };\n    }\n  \n    // 4. Validate constraints\n    const mustContain = fixture.must_contain || [];\n    const mustError = fixture.must_error || false;\n    \n    let passed = true;\n    const reasons = [];\n    \n    if (mustError) {\n      if (!fixtureError) {\n        passed = false;\n        reasons.push('Expected error but got success');\n      }\n    } else {\n      if (fixtureError) {\n        passed = false;\n        reasons.push(`Unexpected error: ${fixtureError.message}`);\n      } else {\n        const responseText = fixtureResult?.text || JSON.stringify(fixtureResult || '');\n        for (const required of mustContain) {\n          if (!responseText.includes(required)) {\n            passed = false;\n            reasons.push(`Missing required text: ${required}`);\n          }\n        }\n      }\n    }\n    \n    // Update pass/fail counts\n    if (passFail[fixtureType]) {\n      if (passed) {\n        passFail[fixtureType].pass++;\n      } else {\n        passFail[fixtureType].fail++;\n      }\n    }\n    \n    results.push({\n      fixture_type: fixtureType,\n      passed: passed,\n      reasons: reasons,\n      response: fixtureResult,\n      error: fixtureError\n    });\n  }\n  \n  // 5. Emit prompt_eval_result span\n  const evalResultId = crypto.randomUUID();\n  const evalResultSpan = {\n    id: evalResultId,\n    seq: 0,\n    entity_type: 'prompt_eval_result',\n    who: 'edge:prompt_eval',\n    did: 'evaluated',\n    this: 'prompt.eval',\n    at: now(),\n    status: 'complete',\n    owner_id: evalSpan.owner_id,\n    tenant_id: evalSpan.tenant_id,\n    visibility: evalSpan.visibility || 'private',\n    related_to: [eval_id || targetVariantId],\n    input: {\n      eval_id: eval_id,\n      variant_id: targetVariantId,\n      fixture_count: fixtures.length\n    },\n    output: {\n      results: results,\n      pass_fail: passFail,\n      total_fixtures: fixtures.length,\n      total_passed: results.filter(r => r.passed).length,\n      total_failed: results.filter(r => !r.passed).length\n    },\n    metadata: {\n      variant_id: targetVariantId\n    }\n  };\n  \n  await insertSpan(evalResultSpan);\n  \n  return {\n    ok: true,\n    eval_result_id: evalResultId,\n    total_fixtures: fixtures.length,\n    total_passed: results.filter(r => r.passed).length,\n    total_failed: results.filter(r => !r.passed).length,\n    pass_fail: passFail,\n    results: results\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

