{"id":"00000000-0000-4000-8000-000000000021","seq":0,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-11-05T00:00:00Z","status":"active","name":"api_key_issuer","description":"Processes api_key_request spans from ledger, creates wallets, generates tokens, and emits api_token_issued spans","code":"globalThis.default = async function apiKeyIssuer(ctx) {\n  const { client } = ctx;\n  const { limit = 10 } = ctx.input || {};\n  \n  // Busca api_key_request pendentes\n  const { rows: requests } = await client.query(`\n    SELECT * FROM ledger.visible_timeline\n    WHERE entity_type = 'api_key_request'\n      AND status = 'pending'\n    ORDER BY at ASC\n    LIMIT $1\n  `, [limit]);\n  \n  console.log(`Found ${requests.length} pending API key requests`);\n  \n  const results = [];\n  \n  for (const req of requests) {\n    const meta = req.metadata || {};\n    const email = meta.email;\n    const tenantId = meta.tenant_id || req.tenant_id;\n    const walletId = `wlt_${tenantId}_${email.split('@')[0]}`;\n    \n    try {\n      // 1. Criar wallet se não existe (via DynamoDB)\n      await ensureWalletExists(walletId, email, tenantId);\n      \n      // 2. Gerar token\n      const token = await generateApiToken();\n      const tokenHash = await calculateTokenHash(token);\n      \n      // 3. Armazenar no DynamoDB\n      await storeTokenInDynamoDB(tokenHash, walletId, tenantId, meta.requested_scopes || []);\n      \n      // 4. Criar span api_token_issued (COM TOKEN PLAINTEXT - única vez!)\n      const issuedSpanId = require('crypto').randomUUID();\n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, status, metadata, owner_id, tenant_id, visibility, links)\n        VALUES ($1, 0, 'api_token_issued', 'kernel:api_key_issuer', 'issued', 'security.token', NOW(), 'complete', $2, $3, $4, 'tenant', $5)\n      `, [\n        issuedSpanId,\n        JSON.stringify({\n          token: token,  // PLAINTEXT - apenas nesta span!\n          token_hash: tokenHash,\n          wallet_id: walletId,\n          scopes: meta.requested_scopes || [],\n          exp: Math.floor(Date.now() / 1000) + (720 * 3600)\n        }),\n        req.owner_id || email,\n        tenantId,\n        JSON.stringify({ caused_by: req.id })\n      ]);\n      \n      // 5. Criar wallet_opened span se wallet foi criado\n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, status, metadata, owner_id, tenant_id, visibility, links)\n        VALUES ($1, 0, 'wallet_opened', 'kernel:api_key_issuer', 'opened', 'wallet', NOW(), 'complete', $2, $3, $4, 'tenant', $5)\n      `, [\n        require('crypto').randomUUID(),\n        JSON.stringify({ wallet_id: walletId, owner_id: email, tenant_id: tenantId }),\n        req.owner_id || email,\n        tenantId,\n        JSON.stringify({ caused_by: req.id })\n      ]);\n      \n      // 6. Atualizar request (append-only)\n      const { rows: seqRows } = await client.query(\n        'SELECT COALESCE(MAX(seq), -1) + 1 as next_seq FROM ledger.universal_registry WHERE id = $1',\n        [req.id]\n      );\n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, status, metadata, owner_id, tenant_id, visibility)\n        VALUES ($1, $2, 'api_key_request', 'kernel:api_key_issuer', 'updated', 'security.api_key', NOW(), 'completed', $3, $4, $5, 'tenant')\n      `, [req.id, seqRows[0].next_seq, req.metadata, req.owner_id || email, tenantId]);\n      \n      results.push({\n        request_id: req.id,\n        status: 'success',\n        token_span_id: issuedSpanId,\n        wallet_id: walletId\n      });\n      \n    } catch (err) {\n      console.error(`Failed to process API key request ${req.id}:`, err.message);\n      \n      // Criar span api_key_request_failed\n      await client.query(`\n        INSERT INTO ledger.universal_registry\n          (id, seq, entity_type, who, did, this, at, status, metadata, owner_id, tenant_id, visibility, links)\n        VALUES ($1, 0, 'api_key_request_failed', 'kernel:api_key_issuer', 'failed', 'security.api_key', NOW(), 'failed', $2, $3, $4, 'tenant', $5)\n      `, [\n        require('crypto').randomUUID(),\n        JSON.stringify({ error: err.message, request_metadata: meta }),\n        req.owner_id || email,\n        tenantId,\n        JSON.stringify({ caused_by: req.id })\n      ]);\n      \n      results.push({ request_id: req.id, status: 'failed', error: err.message });\n    }\n  }\n  \n  return {\n    status: 'complete',\n    processed: requests.length,\n    results: results\n  };\n};\n\nasync function ensureWalletExists(walletId, email, tenantId) {\n  const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');\n  const { DynamoDBDocumentClient, GetCommand, PutCommand } = require('@aws-sdk/lib-dynamodb');\n  const dynamo = DynamoDBDocumentClient.from(new DynamoDBClient({ region: process.env.AWS_REGION || 'us-east-1' }));\n  \n  const result = await dynamo.send(new GetCommand({\n    TableName: process.env.WALLETS_TABLE || 'wallets',\n    Key: { wallet_id: walletId }\n  }));\n  \n  if (!result.Item) {\n    await dynamo.send(new PutCommand({\n      TableName: process.env.WALLETS_TABLE || 'wallets',\n      Item: {\n        wallet_id: walletId,\n        owner_id: email,\n        tenant_id: tenantId,\n        status: 'active',\n        created_at: Math.floor(Date.now() / 1000),\n        items: {}\n      }\n    }));\n  }\n}\n\nasync function generateApiToken() {\n  const { randomBytes } = require('crypto');\n  const random = randomBytes(24).toString('base64url');\n  return `tok_live_${random}`;\n}\n\nasync function calculateTokenHash(token) {\n  const { SecretsManager } = require('@aws-sdk/client-secrets-manager');\n  const { createHmac } = require('crypto');\n  const argon2 = require('argon2');\n  \n  const secrets = new SecretsManager({ region: process.env.AWS_REGION || 'us-east-1' });\n  const pepperSecret = await secrets.getSecretValue({\n    SecretId: process.env.TOKENS_PEPPER_SECRET_ARN\n  });\n  const pepper = JSON.parse(pepperSecret.SecretString).pepper;\n  \n  const hmac = createHmac('sha256', pepper);\n  hmac.update(token);\n  const hmacResult = hmac.digest('hex');\n  \n  const hash = await argon2.hash(hmacResult, {\n    type: argon2.argon2id,\n    memoryCost: 65536,\n    timeCost: 3,\n    parallelism: 4,\n    hashLength: 32\n  });\n  \n  return hash.split('$').pop();\n}\n\nasync function storeTokenInDynamoDB(tokenHash, walletId, tenantId, scopes) {\n  const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');\n  const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');\n  const dynamo = DynamoDBDocumentClient.from(new DynamoDBClient({ region: process.env.AWS_REGION || 'us-east-1' }));\n  \n  await dynamo.send(new PutCommand({\n    TableName: process.env.TOKENS_TABLE || 'auth_api_tokens',\n    Item: {\n      token_hash: tokenHash,\n      wallet_id: walletId,\n      tenant_id: tenantId,\n      scopes: scopes,\n      exp: Math.floor(Date.now() / 1000) + (720 * 3600),\n      status: 'active',\n      token_type: 'api_token',\n      created_at: Math.floor(Date.now() / 1000),\n      created_by: 'kernel:api_key_issuer'\n    }\n  }));\n}","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}

