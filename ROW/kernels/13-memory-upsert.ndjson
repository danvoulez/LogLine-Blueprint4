{"id":"00000000-0000-4000-8000-000000000009","seq":1,"entity_type":"function","who":"system:seed","did":"defined","this":"function","at":"2025-01-01T00:00:00Z","status":"active","name":"memory_upsert_kernel","description":"Upserts memory spans with optional encryption, schema validation, emits memory + memory_audit spans","code":"globalThis.default = async function upsertMemory(ctx) {\n  const { sql, insertSpan, now, crypto } = ctx;\n  const { layer, type, content, tags, schema_id, sensitivity, ttl_at, session_id } = ctx.input || {};\n  \n  if (!layer || !type || !content) {\n    throw new Error('Missing required fields: layer, type, content');\n  }\n  \n  const userId = ctx.env.APP_USER_ID || 'system';\n  const tenantId = ctx.env.APP_TENANT_ID || 'system';\n  const kmsHex = ctx.env.KMS_HEX || process.env.KMS_HEX;\n  \n  // 1. Validate schema_id if provided\n  if (schema_id) {\n    const schemaResult = await sql(\n      'SELECT metadata FROM ledger.visible_timeline WHERE id = $1 AND entity_type = $2 ORDER BY \"when\" DESC LIMIT 1',\n      [schema_id, 'memory_contract']\n    );\n    \n    if (schemaResult.rows.length === 0) {\n      throw new Error(`Memory schema not found: ${schema_id}`);\n    }\n    \n    // TODO: Validate content against schema JSON schema\n  }\n  \n  // 2. Encrypt content if sensitivity != 'public' and KMS_HEX present\n  let encryptedContent = null;\n  let encryptionIv = null;\n  let encryptionTag = null;\n  let contentToStore = content;\n  \n  if (sensitivity !== 'public' && kmsHex) {\n    try {\n      // Use encryption from ctx\n      const encrypted = await crypto.encryptAES256GCM(\n        typeof content === 'string' ? content : JSON.stringify(content),\n        kmsHex\n      );\n      \n      encryptedContent = encrypted.encrypted;\n      encryptionIv = encrypted.iv;\n      encryptionTag = encrypted.tag;\n      contentToStore = { redacted: true }; // Plaintext not stored\n    } catch (e) {\n      console.error('Encryption failed:', e.message);\n      // Continue without encryption if it fails\n    }\n  }\n  \n  // 3. Build memory span\n  const memoryId = crypto.randomUUID();\n  const memorySpan = {\n    id: memoryId,\n    seq: 0,\n    entity_type: 'memory',\n    who: 'kernel:memory_upsert',\n    did: 'upserted',\n    this: `memory.${type}`,\n    at: now(),\n    status: 'active',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    content: contentToStore,\n    metadata: {\n      layer: layer,\n      type: type,\n      schema_id: schema_id || null,\n      tags: tags || [],\n      sensitivity: sensitivity || 'internal',\n      ttl_at: ttl_at || null,\n      session_id: session_id || null,\n      stored_at: Date.now(),\n      encrypted_content: encryptedContent,\n      encryption_iv: encryptionIv,\n      encryption_tag: encryptionTag\n    }\n  };\n  \n  await insertSpan(memorySpan);\n  \n  // 4. Emit memory_audit span with rolling hash\n  const auditId = crypto.randomUUID();\n  \n  // Compute rolling hash (hash of previous audit + current memory)\n  const prevAuditResult = await sql(\n    'SELECT curr_hash FROM ledger.visible_timeline WHERE entity_type = $1 AND related_to @> ARRAY[$2]::uuid[] ORDER BY \"when\" DESC LIMIT 1',\n    ['memory_audit', memoryId]\n  );\n  \n  const prevHash = prevAuditResult.rows[0]?.curr_hash || null;\n  const auditPayload = {\n    action: 'upsert',\n    memory_id: memoryId,\n    prev_hash: prevHash\n  };\n  \n  const auditHashBytes = crypto.blake3(new TextEncoder().encode(JSON.stringify(auditPayload)));\n  const auditHash = crypto.hex(auditHashBytes);\n  \n  const auditSpan = {\n    id: auditId,\n    seq: 0,\n    entity_type: 'memory_audit',\n    who: 'kernel:memory_upsert',\n    did: 'audited',\n    this: 'memory.audit',\n    at: now(),\n    status: 'complete',\n    owner_id: userId,\n    tenant_id: tenantId,\n    visibility: 'private',\n    related_to: [memoryId],\n    input: auditPayload,\n    curr_hash: auditHash,\n    prev_hash: prevHash,\n    metadata: {\n      action: 'upsert',\n      memory_id: memoryId\n    }\n  };\n  \n  await insertSpan(auditSpan);\n  \n  return {\n    ok: true,\n    memory_id: memoryId,\n    audit_id: auditId,\n    encrypted: !!encryptedContent,\n    layer: layer,\n    type: type\n  };\n};","language":"javascript","runtime":"deno@1.x","owner_id":"system","tenant_id":"system","visibility":"public"}
